\documentclass[final]{amsart}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{mlmodern}
\usepackage{todonotes}
\usepackage{mathabx}

\usepackage{rules}

\NewDocumentCommand\IsNegCtx{m}{#1\ \mathit{NegCtx}}
\NewDocumentCommand\IsNegEnv{m}{#1\ \mathit{NegEnv}}
\NewDocumentCommand\IsFilled{m}{#1\ \mathit{Filled}}
\NewDocumentCommand\IsProg{m}{#1\ \mathit{Program}}
\NewDocumentCommand\Let{m}{\operatorname{let}\ #1}
\NewDocumentCommand\In{}{\text{\ in\ }}
\NewDocumentCommand\Fst{m}{\operatorname{fst} #1}
\NewDocumentCommand\Snd{m}{\operatorname{snd} #1}

\NewDocumentCommand\Judg{m}{\textcolor{gray}{Judg:}#1}
\NewDocumentCommand\Deriv{m}{\textcolor{gray}{Deriv:}#1}

\title{The Synthetic Theory of Polynomial Functors}
\author{David Spivak}
\author{Owen Lynch}
\author{Reed Mullanix}
\author{Solomon Bothwell}
\author{Verity Scheel}

\begin{document}
\maketitle

\section{Verity's Rules (Working Document)}

Blah blah blah Martin-L\"of Type Theory.

We will write variables as $x^{(\pm)}, y^{(\pm)}, z^{(\pm)}$ when we are referencing explicit bindings, as opposed to general expressions.
We will use $x^{+}$ for normal variables in the forwards direction of morphisms, $x^{-}$ for sinks (negative variables, which are necessarily in the reverse direction of morphisms), and plain $x$ for binding the positive value being threaded through the reverse direction.
That is, our convention will be that $x^{-} = \lambda x \to (x \mapsto x^{-})$ (eta-expansion of sinks).
In terms of polynomial functors, $x^{+}$ will usually have type $\Base{P}$, and $x^{-}$ and $x$ will both have type $\Fib{P}{x^{+}}$ but as negative and positive terms respectively.

MLTT has three things (``kinds''?):
\begin{enumerate}
  \item Contexts, with variables of types
  \item Types
  \item Terms
\end{enumerate}

To this we add:
\begin{enumerate}
  \item A type of polynomial functors $P, Q : \PolyUniv$, and a type of morphisms between them $\phi, \psi : \Hom{P}{Q}$
  % see it's a nice loop, graphically signifying control flow
  \item Negative (linear) contexts $\Omega$, which introduces sinks (negative variables of negative types) and later will fill in their values (this forms compound contexts $\Gamma | \Omega$, where the vertical bar is mere syntax)
  \item Negative types $A^{-}$, which are exactly like MLTT types but may mention negative values via borrowing (note that ${-}^{-}$ is no longer an operation, just notation to distinguish negative types -- the fundamental distinction is whether they are typechecked in just $\Gamma$ or $\Gamma | \Omega$)
  \item Programs $\pi$, which set negative terms (sinks) to values, which then are reflected in the context $\Omega$
  \item Negative terms $a^{-}$ (sinks), which can be set to values in programs (that is, they are abstracted programs which take in a positive value)
  % \rho for [r]eturn
  \item Morphism bodies $\rho :\Rightarrow Q$, which have a sequence of programs and then conclude in a positive return value and negative fibrational component (this is a technical wart of our presentation, we need to hold onto the right return type $Q$ for the end of the body of the poly-morphism of type $P \Rightarrow Q$, after introducing the bits from $P$)
\end{enumerate}

Programs have a few operations:
\begin{enumerate}
  \item Writing a positive value to a negative term of the same type. We will write it as $a^{+} \mapsto a^{-}$.
  \item Done, the program which does nothing, which is necessary for the grammar to be right-associative. We will write it as $\Done$.
  %\item Borrow, which abstracts over an opaque value of a sink. We do not need this yet, so we omit it. We may also restrict it to borrowing variables only, as opposed to general negative terms.
  \item Unpack, which splits a sigma-sink into two sinks (with a type dependency). We will write it as $v^{-} \prec (x^{-}, y^{-})$.
  \item Pair, which bundles up two sinks (with a type dependency) into a sigma-sink. This can be implemented in user-land: $(a^{-}, b^{-}) := \lambda\ ab \to (\Fst{ab} \mapsto a^{-}); (\Snd{ab} \mapsto b^{-})$.
  \item Morphism application $(p^{+}, p^{-}) \xrightarrow{\phi} (q^{+}, q^{-})$ can also be implemented in user-land (although it loses sharing but eh we don't have that anyways).
\end{enumerate}

\section{Overview on linearity}

We will preview some rules here, but they will be fully defined and presented in the following sections.

Linearity is checked by writing a negative variable's written value in context $\Omega$, never allowing it to be written twice, and checking that all variables introduced in $\Omega$ have been written by the end of a morphism-body.

Writing a variable only occurs in negative terms in programs and morphism bodies.
This introduces additional definitional equalities for $\Borrow a^{-}$ into scope.
Namely, $a \mapsto x^{-}$ allows for the reduction $\Borrow x^{-} \equiv a$, like so:

\begin{mathpar}
  \inferrule[\Deriv{Borrow-reduce}] {
  } {
    \Gamma \mid \Omega_L, (x^{-} : A^{-}), \Omega_M, (a \mapsto x^{-}), \Omega_R \vdash \Borrow x^{-} \equiv a : A
  }
\end{mathpar}

\textsc{Todo}: what to do about compound negative terms? disallow them? yes! definitely.

Negative terms in negative types are not consumed.
In particular, mentioning a negative variable in $\Borrow a^{-}$ does not consume it, so this means that the only difference between types and negative types are that the latter may mention $\Borrow a^{-}$.

\begin{mathpar}
  \inferrule[\Deriv{Borrow-negative}] {
    \Gamma \mid \Omega \vdash a^{-} : A^{-}
  } {
    \Gamma \mid \Omega \vdash \Borrow a^{-} : A
  }
\end{mathpar}

This means that the MLTT fragment does not need to care about linearity.
It only needs to pass along the compound context $\Gamma \mid \Omega$.
For example, the application rule looks like this:

\begin{mathpar}
  \inferrule[\Deriv{Ap}] {
    \Gamma \mid \Omega \vdash f : (a : A) \to B[a]\\
    \Gamma \mid \Omega \vdash v : A
  } {
    \Gamma \mid \Omega \vdash f(v) : B[v]
  }
\end{mathpar}

%It would be nice to get rid of the morphism-body, since various judgments are polymorphic over it in their return (e.g. sequencing and negsima-elim), but let's gloss over that for now.
%Sequencing is right-associative: each statement may bind variables and write values that appear in all following statements.
%In fact that needs to be baked into the syntax, so that the environment can remain a reader context and not devolve into writer or state context.

%\begin{mathpar}
%  \inferrule[\Deriv{Seq-Program}] {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi_1}\\
%    \Gamma \mid \Psi \mid {\downarrow \pi_1}; \chi \vdash \IsProg{\pi_2}
%  } {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi_1 ; \pi_2}
%  }
%\end{mathpar}
%\begin{mathpar}
%  \inferrule[\Deriv{Seq-Body}] {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi}\\
%    \Gamma \mid \Psi \mid {\downarrow \pi}; \chi \vdash \rho :\Rightarrow Q
%  } {
%    \Gamma \mid \Psi \mid \chi \vdash \pi ; \rho :\Rightarrow Q
%  }
%\end{mathpar}

\pagebreak

\section{Negative contexts and types}

Negative contexts are a bit weird in my presentation here: they introduce variables of specified negative types, but they also write them to values.
They are inductively generated with three constructors: empty, introducing a variable, and writing a variable.

Negative types are exactly regular types with access to $\Omega$ ($\Borrow{x^{-}}$ for all negative variables $x^{-}$ in scope thus far, and any known definitional equalities from them), so we omit its derivation rules as they are inherited from MLTT.

\begin{mathpar}
  \inferrule[\Judg{Neg-ctx}] {
    \IsCtx{\Gamma}
  } {
    \Gamma \vdash \IsNegCtx{\Omega}
  }

  \inferrule[\Judg{Neg-type}] {
  	\IsCtx{\Gamma}\\
    \Gamma \vdash \IsNegCtx{\Omega}
  } {
    \Gamma \mid \Omega \vdash \IsTp{A^{-}}
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[\Deriv{Neg-ctx-empty}] {
  	\IsCtx{\Gamma}
  } {
    \Gamma \vdash \IsNegCtx{\cdot}
  }
\end{mathpar}

We can always introduce a negative variable of a valid negative type (assuming uniqueness of variables blah blah):

\begin{mathpar}
  \inferrule[\Deriv{Neg-ctx-intro}] {
    \Gamma \vdash \IsNegCtx{\Omega}\\
    \Gamma \mid \Omega \vdash \IsTp{A^{-}}
  } {
    \Gamma \vdash \IsNegCtx{\Omega, (x^{-} : A^{-})}
  }
\end{mathpar}

But to write to a variable, we need to know that it is defined in context (with the corresponding type) \emph{and} was not yet written to (the asterisk here is a wildcard):

\begin{mathpar}
  \inferrule[\Deriv{Neg-ctx-write}] {
    \Gamma \vdash \IsNegCtx{\Omega}\\
    \Gamma \vdash a : A\\
    (x^{-} : A^{-}) \in \Omega\\
    (* \mapsto x^{-}) \notin \Omega\\
  } {
    \Gamma \vdash \IsNegCtx{\Omega, (a \mapsto x^{-})}
  }
\end{mathpar}

Ugly? I don't know, I'm just hoping it works out.


The linearity check is ensured by never writing to the same variable twice and by checking that each variable in $\Omega$ is written exactly once by the end of the hom-body.

In particular, this is used for program extraction of the backwards action on fibrations, by seeing what the input $p^{-}$ is set to in the environment when the output $q^{-}$ is written with a value.






\section{Negative terms and programs and program environments}

Programs are exactly the bodies of eta-expanded negative terms:

\begin{mathpar}
  \inferrule[\Deriv{Neg-Eta}] {
    \Gamma, a : A \mid \Omega \vdash \IsProg{\pi}
  } {
    \Gamma \mid \Omega \vdash (\lambda a \to \pi) : A^{-}
  }
\end{mathpar}

As an example, there is a negative term $\mathsf{drop}$ that accepts anything and writes nothing: $\mathsf{drop} := (\lambda a \to \Done{}) : A^{-}$.

Programs can write positive values $a$ to negative terms $a^{-}$.
Two things:
\begin{enumerate}
\item
Note that $a$ cannot depend on any negative terms (in particular, cannot borrow).
That means that $a^{-}$ needs its type $A^{-}$ to reduce to a term that does not mention borrowed values, either by having no dependence on other sinks in the first place or by already being written to a value from previous writes in $\Omega$.
\item
Speaking of $\Omega$, $a^{-}$ may not be a variable, so we need to be able to write out the side-effects of writing to it back into $\Omega'$.
We do this with an operation ${\downarrow (a \mapsto a^{-})}$ that we will write out later.
\end{enumerate}

\begin{mathpar}
  \inferrule[\Deriv{Neg-Write}] {
    \Gamma \vdash a : A\\
    \Gamma \mid \Omega \vdash a^{-} : A^{-}\\
    \Gamma \mid \Omega, {\downarrow (a \mapsto a^{-})} \vdash \IsProg{\pi}
  } {
    \Gamma \mid \Omega \vdash \IsProg{(a \mapsto a^{-}); \pi}
  }
\end{mathpar}


We can let-bind negative terms, but it doesn't really buy us much at this point.
(Since we will never borrow against them.)

\begin{mathpar}
  \inferrule[\Deriv{Lending??}] {
    \Gamma \mid \Omega \vdash a^{-} : A^{-}\\
    \Gamma \mid \Omega, x^{-} : A^{-}, {\downarrow (\Borrow{x^{-}} \mapsto a^{-})} \vdash \IsProg{\pi_2}
  } {
    \Gamma \mid \Omega \vdash \IsProg{\Let{x^{-}} : A^{-} := a^{-}; \pi_2}
  }
\end{mathpar}


\subsection{Running programs into context}

To write programs into context, we need to run them.
(Note: this is where I differ from Reed's rules in that I want to be able to write to arbitrary negative terms, instead of simplifying the rules to only write to negative variables.)

On the one hand, it is a bit weird to write out all the rules for this kind of evaluation interleaved with our typing judgments.
On the other hand, we know something like it is necessary: our implementation needs to run the negative fragment as it is typechecking.

(Note that this isn't an inductive constructor for negative contexts, it is a function in the metatheory that produces negative contexts.)


\begin{mathpar}
  \inferrule[\Judg{Exec}] {
    \Gamma \vdash \IsNegCtx{\Omega}\\
    \Gamma \mid \Omega \vdash \IsProg{\pi}
  } {
    \Gamma \vdash \IsNegCtx{\Omega, \downarrow \pi}
  }
\end{mathpar}

Uhh I am describing its behavior in English for now:
A program is a series of writes that we want to write into context (and it ends with $\Done{}$).
\begin{enumerate}
\item
Writing to a variable is easy $a \mapsto x^{-}$: we add the appropriate constructor into context, so we produce $\Omega, (a \mapsto x^{-})$.
\item
Writing to an eta-expanded negative term is also easy $a \mapsto (\lambda x \to \pi[x])$: we substitute the value in we now know the program should use, and write that program into context, $\Omega, \downarrow \pi[a]$.
(This is recursive.)
\item
I guess there are also let bindings but it should be obvious what to do there?
All other sugar will be implemented on top of let bindings.
\item
Oh I guess we have Unpack too.
\end{enumerate}



\section{Morphism body}

This provides the forward component $p^{+}$ and adds an obligation $p^{-}$, then checks that the body of the morphism $\rho$ will fulfill the obligation.

\begin{mathpar}
  \inferrule[\Deriv{Morph-Intro}] {
    \Gamma, p^{+} : \Base{P} \mid p^{-} : \Fib{P}{p^{+}} \vdash \rho :\Rightarrow Q\\
  } {
    \Gamma \vdash (\lambda p^{+} p^{-} \rightsquigarrow \rho) : P \Rightarrow Q
  }
\end{mathpar}

The obligation is fulfilled when the body ends, providing a positive value for the base and a negative sink for the fibration, and every negative variable has been set to a value in $\Omega$ after writing to $q^{-}$ (yes we invent a new variable $q$ to write to $q^{-}$).

\begin{mathpar}
  \inferrule[\Deriv{Body-Done}] {
    \Gamma \vdash q^{+} : \Base{Q}\\
    \Gamma \mid \Omega \vdash q^{-} : (\Fib{Q}{q^{+}})^{-}\\
    \IsFilled{\Omega, \downarrow (q \mapsto q^{-})}
  } {
    \Gamma \mid \Omega \vdash (q^{+} \leftsquigarrow q^{-}) :\Rightarrow Q
  }
\end{mathpar}

The action on fibrations can be recovered as something like $\lambda q. p$ where $\Gamma, p^{+} : \Base{P}, q^{+} : \Base{Q} \mid \Omega$, where $\Omega := (p^{-} : \Fib{P}{p^{+}}, \downarrow (q \mapsto q^{-})) = (p^{-} : \Fib{P}{p^{+}}, ..., (p \mapsto p^{-}), ...)$ means $p^{-}$ gets set to $p$ in the process of setting $q^{-}$ to $q$.

Apply a morphism.
This takes a base, fib pair and turns it into a new base, fib pair by applying the forward and backwards components of the morphism.
It can be implemented via positive and negative let in the obvious way, so it is a conservative extension, but then again, so is everything we are doing here.

\textsc{Todo}: $p^{-}$ needs to be a variable here, since we are borrowing against it thus it needs a cell allocated for it??

\begin{mathpar}
  \inferrule[\Deriv{Morph-Ap}] {
    \Gamma \vdash \phi : P \Rightarrow Q\\
  	\Gamma \vdash p^{+} : \Base{P}\\
  	\Gamma \mid \Omega \vdash p^{-} : (\Fib{P}{p^{+}})^{-}\\\\
	\Gamma' := \Gamma, q^{+} := \Base{\phi}(p^{+}) : \Base{Q}\\\\
	\Omega' := \Omega, q^{-} : (\Fib{Q}{q^{+}})^{-}, (\Fib{\phi}{p^{+}}(\Borrow{p^{-}}) \mapsto q^{-})\\\\
    \Gamma' \mid \Omega' \vdash \IsProg{\pi}
  } {
    \Gamma \mid \Omega \vdash \IsProg{(p^{+}, p^{-}) \xrightarrow{\phi} (q^{+}, q^{-}); \pi}
  }
\end{mathpar}




\section{Sigmas}

Consumes $ab^{-}$, splitting it into two new sinks $(x^{-}, y^{-})$ whose values get paired and written to $ab^{-}$.
Note that the type of the second sink depends on the value written to the first sink.
Since $\Borrow{x^{-}}$ cannot be mentioned in user-code, due to the typing restriction in \textsc{\Deriv{Neg-Write}}, if $B^{-}[\Borrow{x^{-}}]$ does not reduce by virtue of being a constant family, one must write to $x^{-}$ before $y^{-}$.
%(In theory one could borrow ahead of time but it requires cycle checking, see above.)

\begin{mathpar}
  \inferrule[\Deriv{Unpack}] {
    \Gamma \mid \Omega_1 \vdash ab^{-} : (a : A) \times B^{-}[a]\\
    \Omega_2 := \Omega_1, x^{-} : A^{-}, y^{-} : B^{-}[\Borrow{x^{-}}], {\downarrow ((\Borrow{x^{-}}, \Borrow{y^{-}}) \mapsto ab^{-})} \\
    \Gamma \mid \Omega_2 \vdash \IsProg{\pi}\\
  } {
    \Gamma \mid \Omega_1 \vdash ab^{-} \prec (x^{-}, y^{-}); \IsProg{\pi}
  }
\end{mathpar}

The inverse can be implemented simply in user-land, as $$\Let{ab^{-}} := \lambda\ ab \to (\Fst{ab} \mapsto a^{-}); (\Snd{ab} \mapsto b^{-}).$$

Probably the better UX is to provide (un)tensoring for polynomials, that handles forwards and backwards directions at once.
Macros, anyone???



\end{document}