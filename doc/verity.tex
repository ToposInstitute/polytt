\documentclass[final]{amsart}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{mlmodern}
\usepackage{todonotes}
\usepackage{mathabx}

\NewDocumentCommand\IsCtx{m}{#1\ \mathit{Ctx}}
\NewDocumentCommand\IsNegCtx{m}{#1\ \mathit{NegCtx}}
\NewDocumentCommand\IsFilled{m}{#1\ \mathit{Filled}}
\NewDocumentCommand\IsHomCtx{m}{#1\ \mathit{HomCtx}}
\NewDocumentCommand\IsHomEnv{m}{#1\ \mathit{HomEnv}}
\NewDocumentCommand\IsTp{m}{#1\ \mathit{Type}}
\NewDocumentCommand\IsPoly{m}{#1\ \mathit{Poly}}
\NewDocumentCommand\IsHom{mm}{#1\ \mathit{Hom}(#2)}
\NewDocumentCommand\Base{m}{\mathit{Base}\ #1}
\NewDocumentCommand\Fib{mm}{\mathit{Fib}\ #1\ #2}
\NewDocumentCommand\Read{m}{\mathit{borrow}\ #1}

\NewDocumentCommand\TpUniv{}{\mathcal{U}}
\NewDocumentCommand\PolyUniv{}{\mathit{Poly}}
\NewDocumentCommand\Hom{mm}{#1 \Rightarrow #2}


\title{The Synthetic Theory of Polynomial Functors}
\author{Reed Mullanix}
\author{Verity Scheel}
\author{Solomon Bothwell}

\begin{document}
\maketitle

\section{Verity's Rules}

Blah blah blah Martin-L\"of Type Theory.

MLTT has three things:
\begin{enumerate}
  \item Contexts, with variables of types
  \item Types
  \item Terms
\end{enumerate}

To this we add:
\begin{enumerate}
  \item A type of polynomial functors and a type of morphisms between them
  \item Negative (linear) contexts, with variables of negative types \emph{and} their values when written to
  \item Negative types, which may mention negative values via reading
  \item Negative terms, which can be set to values
  \item Programs, which set negative terms to values
  \item Morphism bodies, which have a sequence of programs and then conclude in a return value and fibration
\end{enumerate}

Linearity is checked by writing a negative variable's written value in context, never allowing it to be written twice, and checking that all variables have been written by the end of a morphism-body.

Writing a variable only occurs in negative terms in programs and morphism bodies.
This introduces additional definitional equalities for $\Read a^{-}$ into scope.
Namely, $x^{-} := a : A^{-}$ allows for the reduction $\Read x^{-} \mapsto a$.

\begin{mathpar}
  \inferrule[Deriv:Read-reduce] {
  } {
    \Gamma \mid \Psi_L, (a =: x^{-} : A^{-}), \Psi_R \vdash \Read x^{-} \cong a : A
  }
\end{mathpar}

Negative terms in negative types are not consumed.
In particular, mentioning a negative variable in $\Read a^{-}$ does not consume it, so this means that the only difference between types and negative types are that the latter may mention $\Read a^{-}$.

\begin{mathpar}
  \inferrule[Deriv:Read-negative] {
    \Gamma \mid \Psi \vdash a^{-} : A^{-} \rightsquigarrow \_
  } {
    \Gamma \mid \Psi \vdash \Read a^{-} : A
  }
\end{mathpar}

This means that the MLTT fragment does not need to care about linearity.
It only needs to pass along the compound context $\Gamma \mid \Psi$.
For example, the application rule looks like this:

\begin{mathpar}
  \inferrule[Deriv:Ap] {
    \Gamma \mid \Psi \vdash f : (a : A) \to B[a]\\
    \Gamma \mid \Psi \vdash v : A
  } {
    \Gamma \mid \Psi \vdash f(v) : B[v]
  }
\end{mathpar}

It would be nice to get rid of the morphism-body, since various judgments are polymorphic over it in their return (e.g. sequencing and negsima-elim), but let's gloss over that for now.

\begin{mathpar}
  \inferrule[Deriv:Seq-Program] {
    \Gamma \mid \Psi_1 \vdash \pi_1 \rightsquigarrow \Psi_2\\
    \Gamma \mid \Psi_2 \vdash \pi_2 \rightsquigarrow \Psi_3
  } {
    \Gamma \mid \Psi_1 \vdash \pi_1 ; \pi_2 \rightsquigarrow \Psi_3
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[Deriv:Seq-Body] {
    \Gamma \mid \Psi_1 \vdash \pi \rightsquigarrow \Psi_2\\
    \Gamma \mid \Psi_2 \vdash \rho :\Rightarrow Q
  } {
    \Gamma \mid \Psi_1 \vdash \pi ; \rho :\Rightarrow Q
  }
\end{mathpar}

\section{Negative contexts and types}

Negative contexts have variables of specified negative types that may be set to values.
We will see whether it depends on order???

\begin{mathpar}
  \inferrule[Judg:Neg-ctx] {
  } {
    \Gamma \vdash \IsNegCtx{\Psi}
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[Judg:Full] {
  } {
    \IsFilled{\Psi}
  }
\end{mathpar}

\section{Negative terms and programs}

Hack: using $\cdot$ to mean ``The particular variable we abstracted over in this negative term'' (since it may only abstract over one).

\begin{mathpar}
  \inferrule[Deriv:Neg-Eta] {
    \Gamma, a : A \mid \Psi_1 \vdash \pi \rightsquigarrow \Psi_2
  } {
    \Gamma \mid \Psi_1 \vdash (\lambda a \to \pi) : A^{-} \rightsquigarrow \Psi_2[a := \cdot]
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Deriv:Neg-Set] {
    \Gamma \vdash a : A\\
    \Gamma \mid \Psi_1 \vdash a^{-} : A^{-} \rightsquigarrow \Psi_2
  } {
    \Gamma \mid \Psi_1 \vdash (a =: a^{-}) \rightsquigarrow \Psi_2[\cdot := a]
  }
\end{mathpar}

Programs have a few operations:
\begin{enumerate}
  \item Write, of course
  \item Read (borrow), which abstracts over an opaque value of a wire.
  \item Pair, which bundles up two wires (with a type dependency) into a sigma-wire
  \item Unpack, which splits a sigma-wire into two wires (with a type dependency)
  \item I don't think morphism application really needs to be a fundamental operation at this point?
\end{enumerate}

\section{Morphism body}

\begin{mathpar}
  \inferrule[Deriv:Morph-Intro] {
    \Gamma, p^{+} : \Base{P} \mid p^{-} : \Fib{P}{p^{+}} \vdash \rho :\Rightarrow Q\\
  } {
    \Gamma \vdash (\lambda p^{+} p^{-} \rightsquigarrow \rho) : P \Rightarrow Q
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Deriv:Body-Done] {
    \Gamma \vdash q^{+} : \Base{Q}\\
    \Gamma \mid \Psi_1 \vdash q^{-} : (\Fib{Q}{q^{+}})^{-} \rightsquigarrow \Psi_2\\
    \IsFilled{\Psi_2}
  } {
    \Gamma \mid \Psi_1 \vdash (q^{+} \leftsquigarrow q^{-}) :\Rightarrow Q
  }
\end{mathpar}

The action on fibrations can be recovered as something like $\lambda q. p$ where $\Gamma, p^{+} : \Base{P}, q^{+} : \Base{Q} \mid q^{-} := q : \Fib{Q}{q^{+}}, p^{-} := p : \Fib{P}{p^{+}}$, where $p^{-}$ gets set to $p$ in the process of setting $q^{-}$ to $q$.

\section{Sigmas}


\begin{mathpar}
  \inferrule[Deriv:Unpack] {
    \Gamma \mid \Psi_1 \vdash ab^{-} : (a : A) \times B^{-}[a] \rightsquigarrow \Psi_2\\
    \Gamma \mid \Psi_2, a^{-} : A^{-}, b^{-} : B^{-}[\Read{a^{-}}] \vdash \pi \rightsquigarrow \Psi_3\\
  } {
    \Gamma \mid \Psi_1 \vdash ab^{-} \prec (a^{-}, b^{-}); \pi \rightsquigarrow \Psi_i
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[Deriv:Pair] {
    \Gamma \mid \Psi_1 \vdash ab^{-} : (a : A) \times B^{-}[a] \rightsquigarrow \Psi_2\\
    \Gamma \mid \Psi_2, a^{-} : A^{-}, b^{-} : B^{-}[\Read{a^{-}}] \vdash \pi \rightsquigarrow \Psi_3\\
  } {
    \Gamma \mid \Psi_1 \vdash ab^{-} \prec (a^{-}, b^{-}); \pi \rightsquigarrow \Psi_i
  }
\end{mathpar}


\pagebreak

\pagebreak

\pagebreak

















\section{Polynomials}

We omit the standard rules for Martin L\"of Type Theory with Tarski Universes. For simplicity,
we shall assume that the universe $\TpUniv{}$ codes itself. This inconsistency can be resolved
by instead using a tower of universes. We start by adding a new judgement $\Gamma \vdash \IsPoly{A}$,
which denotes that $A$ is a polynomial functor. It has the following formation rule:

\begin{mathpar}
  \inferrule[Poly-formation] {
    \Gamma \vdash \IsTp{A} \\
    \Gamma, a : A \vdash \IsTp{B} \\
  } {
    \Gamma \vdash \IsPoly{(a : A) \times B\ a}
  }
\end{mathpar}

We also add the following rules for obtaining the base of a polynomial, along with
the fibre of a polynomial at a base.

\begin{mathpar}
  \inferrule[Poly-base] {
    \Gamma \vdash \IsPoly{P}
  } {
    \Gamma \vdash \IsTp{\Base{P}}
  }
  \and
  \inferrule[Poly-fibre] {
    \Gamma \vdash \IsPoly{P} \\
    \Gamma \vdash i : \Base{P}
  } {
    \Gamma \vdash \IsTp{\Fib{P}{i}}
  }
\end{mathpar}

The base and fibre operations do what one would expect when applied to a concrete polynomial.

\begin{mathpar}
  \inferrule[Poly-base-decoding] {
  } {
    \Base{(a : A) \times B\ a} \equiv A
  }
  \and
  \inferrule[Poly-fibre-decoding] {
    \Gamma \vdash \IsTp{A} \\
    \Gamma, a : A \vdash \IsTp{B} \\
    \Gamma \vdash i : \Base{(a : A) \times B\ a}
  } {
    \Fib{((a : A) \times B\ a)}{i} \equiv B\ i
  }
\end{mathpar}

\section{Morphisms of Polynomials}

We proceed by defining a type of morphisms between polynomials.

\begin{mathpar}
  \inferrule[Hom-formation] {
    \Gamma \vdash \IsPoly{P} \\
    \Gamma \vdash \IsPoly{Q} \\
  } {
    \Gamma \vdash \IsTp{P \Rightarrow Q}
  }
\end{mathpar}

\subsection{Hom Environments}

The introduction and elimination rules for this type are the source of all of the power
\emph{and} complexity of the theory, so we will need to build out some machinery before we
present them. To start, we define hom environments.

\begin{mathpar}
  \inferrule[Hom-env-empty]{
    \\
  } {
    \Gamma \vdash \IsHomEnv{\cdot}
  }
  \and
  \inferrule[Hom-env-bind]{
    \Gamma \vdash \IsHomEnv{\rho} \\
    a^{-}\ \text{is a name}
  } {
    \Gamma \vdash \IsHomEnv{\rho, a^{-}}
  }
  \and
  \inferrule[Hom-env-set]{
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \vdash v : A \\
    a^{-}\ \text{is a name}
  } {
    \Gamma \vdash \IsHomEnv{\rho, a^{-} \coloneqq v}
  }
\end{mathpar}

We shall gloss over any difficulties with name freshness, and gesture vaguely in the direction
of nameless representations if pressed. We also define a meta-operation $\rho[a^{-} \coloneqq v]$, which
replaces an $a^{-}$ in an environment $\rho$ with $a^{-} \coloneqq v$. This is defined by induction over
the environment. Furthermore, note that the rule for setting a binding in an environment $\rho$ does
\emph{not} allow for the the value $v$ to depend on earlier entries in $\rho$.

We now define all of the normal judgments relative to some environment $\rho$.

\begin{mathpar}
  \inferrule[Type-in-env]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho}
  } {
    \Gamma \mid \rho \vdash \IsTp{A^{+}}
  }
  \and
  \inferrule[Term-in-env]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsTp{A^{+}}
  } {
    \Gamma \mid \rho \vdash a : A^{+}
  }
  \and
  \inferrule[Type-eq-in-env]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsTp{A^{+}} \\
    \Gamma \mid \rho \vdash \IsTp{B^{+}}
  } {
    \Gamma \mid \rho \vdash A^{+} \equiv B^{+}\ \mathit{Type}
  }
  \and
  \inferrule[Term-eq-in-env]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsTp{A} \\
    \Gamma \mid \rho \vdash \IsTp{x} : A^{+} \\
    \Gamma \mid \rho \vdash \IsTp{y} : A^{+}
  } {
    \Gamma \mid \rho \vdash x \equiv y : A^{+}
  }
\end{mathpar}

We can read variables from an environment.

\begin{mathpar}
  \inferrule[Hom-env-read]{
    a^{-} \in \rho
  } {
    \Gamma \mid \rho \vdash \Read{a^{-}} : A^{+}
  }
\end{mathpar}

All of the rules for types in the base theory are copied over to the environment relative
ones. We shall omit these for brevity, though we shall highlight the fact that we have an
environment relative conversion rule.

\begin{mathpar}
  \inferrule[Conversion-in-env]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsTp{A} \\
    \Gamma \mid \rho \vdash \IsTp{B} \\
    \Gamma \mid \rho \vdash A \equiv B\ \mathit{Type} \\
    \Gamma \mid \rho \vdash x : B
  } {
    \Gamma \mid \rho \vdash x : A \\
  }
\end{mathpar}

\subsection{Hom Contexts and Sinks}

We now give rules for linear Hom contexts, as well as a judgement for deriving
``sink'' terms from linear contexts.

\begin{mathpar}
  \inferrule[Hom-context-empty]{
    \\
  } {
    \Gamma \mid \rho \vdash \IsHomCtx{\cdot}
  }
  \and
  \inferrule[Hom-context-bind]{
    \Gamma \mid \rho \vdash \IsHomCtx{\Psi} \\
    \Gamma \mid \rho \vdash \IsTp{A}
  } {
    \Gamma \mid \rho \vdash \IsHomCtx{\Psi, a^{-} : A}
  }
  
  \inferrule[Sink-term] {
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsHomCtx{\Psi} \\
    \Gamma \vdash \IsTp{A} \\
    \Gamma \vdash \IsHomEnv{\theta} \\
  } {
    \Gamma \mid \rho \mid \Psi \vdash a^{-} : A^{-} \rightsquigarrow \theta
  }
\end{mathpar}

Linearity of the Hom contexts is ensured by the following rule.
The intuition here is that in order to discharge an obligation $a^{-}$,
we are required to provide it with a value of the appropriate type.

\begin{mathpar}
  \inferrule[Sink-linear-var] {
    \Gamma \vdash a^{+}  : A
  } {
    \Gamma \mid \rho \mid a^{-} : A^{-} \vdash a^{-}[a^{+}] : A^{-} \rightsquigarrow a^{-} \coloneqq a^{+}
  }
\end{mathpar}

\subsection{Hom Expressions}

We proceed by defining a new judgement describing hom expressions.

\begin{mathpar}
  \inferrule[Hom-expr]{
    \IsCtx{\Gamma} \\
    \Gamma \vdash \IsHomEnv{\rho} \\
    \Gamma \mid \rho \vdash \IsHomCtx{\Psi} \\
    \Gamma \vdash \IsPoly{Q}
  }{
    \Gamma \mid \rho \mid \Psi \vdash \IsHom{\phi}{Q}
  }
  \and
  \inferrule[Hom-set]{
    \Gamma \vdash a^{+} : A \\
    \Gamma, x : A \mid \rho \mid \Psi_1 \vdash b^{-} : B^{-} \rightsquigarrow \theta \\
    \Gamma, \rho \cup \theta[a^{+}/x] , \Psi_2 \vdash \IsHom{\phi}{Q}
  }{
    \Gamma \mid \rho \mid \Psi_1, \Psi_2 \vdash \IsHom{a^{+} \rightarrow (\lambda x. b^{-});\phi}{Q}
  }
  \and
  \inferrule[Hom-done]{
    \Gamma \vdash q^{+} : \Base{Q} \\
    \Gamma, x : \Fib{Q}{q^+} \mid \rho \mid \Psi \vdash q^{-} : A^{-}
  } {
    \Gamma \mid \rho \mid \Psi \vdash \IsHom{(q^+, \lambda x. q^{-})}{Q}
  }
\end{mathpar}

Note that we lambda abstract a variable $x$ when defining the sink expression. This is not essential,
but allows us to avoid writing a point-free mess. This also removes the need for a separate
sink application rule, as it can be handled by function application.

\subsection{Hom Introduction and Elimination}

\begin{mathpar}
  \inferrule[Hom-intro]{
    \Gamma, p^{+} : \Base{p} \mid \cdot \mid p^{-} : \Fib{P}{p^{+}} \vdash \IsHom{\phi}{Q}
  } {
    \Gamma \vdash \lambda p^{+} p^{-} \rightsquigarrow \phi : P \Rightarrow Q
  }
  \and
  \inferrule[Hom-elim]{
    \Gamma \vdash f : P \Rightarrow Q \\
    \Gamma \vdash p^{+} : \Base{P}
  } {
    \Gamma \vdash f p^{+} : (q^{+} : \Base{Q}) \times (\Fib{Q}{q^{+}} \to \Fib{P}{p^+})
  }
\end{mathpar}

\section{Sink Elimination}

We need to also have rules for eliminating sink values in hom expressions.

\todo{How do we handle the $\theta$ here? I want to instantiate it with $(\Read{a^{-}}, \Read{b^{-}})$,
  but that's not allowed currently, as can't have read chains in $\rho$.}
\begin{mathpar}
  \inferrule[Sigma-sink-elim] {
    \Gamma, x : (a : A) \times B\ a \mid \rho \mid \Psi_1 \vdash c^{-} : C^{-} \rightsquigarrow \theta \\
    \Gamma \mid \rho, a^{-}, b^{-} \mid \Psi_2, a^{-} : A, b^{-} : B(\Read{a^{-}}) \vdash \IsHom{\phi}{Q}
  } {
    \Gamma \mid \rho \mid \Psi_1 \vdash \IsHom{\mathsf{unpack}\ ab^{-} \to (a^{-}, b^{-}); \phi}{Q}
  }
\end{mathpar}

\end{document}