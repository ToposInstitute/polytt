\documentclass[final]{amsart}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{mlmodern}
\usepackage{todonotes}
\usepackage{mathabx}

\NewDocumentCommand\IsCtx{m}{#1\ \mathit{Ctx}}
\NewDocumentCommand\IsNegCtx{m}{#1\ \mathit{NegCtx}}
\NewDocumentCommand\IsNegEnv{m}{#1\ \mathit{NegEnv}}
\NewDocumentCommand\IsFilled{m}{#1\ \mathit{Filled}}
\NewDocumentCommand\IsHomCtx{m}{#1\ \mathit{HomCtx}}
\NewDocumentCommand\IsHomEnv{m}{#1\ \mathit{HomEnv}}
\NewDocumentCommand\IsTp{m}{#1\ \mathit{Type}}
\NewDocumentCommand\IsProg{m}{#1\ \mathit{Program}}
\NewDocumentCommand\IsPoly{m}{#1\ \mathit{Poly}}
\NewDocumentCommand\IsHom{mm}{#1\ \mathit{Hom}(#2)}
\NewDocumentCommand\Base{m}{\mathit{Base}\ #1}
\NewDocumentCommand\Fib{mm}{\mathit{Fib}\ #1\ #2}
\NewDocumentCommand\Borrow{m}{\operatorname{borrow}\ #1}
\NewDocumentCommand\Let{m}{\operatorname{let}\ #1}
\NewDocumentCommand\In{}{\text{\ in\ }}
\NewDocumentCommand\Fst{m}{\operatorname{fst} #1}
\NewDocumentCommand\Snd{m}{\operatorname{snd} #1}

\NewDocumentCommand\TpUniv{}{\mathcal{U}}
\NewDocumentCommand\PolyUniv{}{\mathit{Poly}}
\NewDocumentCommand\Hom{mm}{#1 \Rightarrow #2}

\NewDocumentCommand\Judg{m}{\textcolor{gray}{Judg:}#1}
\NewDocumentCommand\Deriv{m}{\textcolor{gray}{Deriv:}#1}

\title{The Synthetic Theory of Polynomial Functors}
\author{David Spivak}
\author{Owen Lynch}
\author{Reed Mullanix}
\author{Solomon Bothwell}
\author{Verity Scheel}

\begin{document}
\maketitle

\section{Verity's Rules}

Blah blah blah Martin-L\"of Type Theory.

We will write variables as $x^{(\pm)}, y^{(\pm)}, z^{(\pm)}$ when we are referencing explicit bindings, as opposed to general expressions.
We will use $x^{+}$ for normal variables in the forwards direction of morphisms, $x^{-}$ for sinks (negative variables, which are necessarily in the reverse direction of morphisms), and plain $x$ for binding the positive value being threaded through the reverse direction.
That is, our convention will be that $x^{-} = \lambda x \to (x \mapsto x^{-})$ (eta-expansion of sinks).

MLTT has three things:
\begin{enumerate}
  \item Contexts, with variables of types
  \item Types
  \item Terms
\end{enumerate}

To this we add:
\begin{enumerate}
  \item A type of polynomial functors $P, Q : \PolyUniv$ and a type of morphisms between them $\Hom{P}{Q}$
  \item Negative (linear) contexts $\Psi$, with variables of negative types
  \item Negative types $A^{-}$, which are exactly like MLTT types but may mention negative values via borrowing (note that ${-}^{-}$ is no longer an operation, just notation to distinguish negative types)
  \item Programs $\pi$, which set negative terms to values
  \item Program environments $\chi$, which are normalized programs $\chi = {\downarrow \pi}$ writing variables (as opposed to generalized negative terms) in \emph{cons}-order (not \emph{snoc}!)
  \item Negative terms $a^{-}$, which can be set to values in programs
  \item Morphism bodies $\phi$, which have a sequence of programs and then conclude in a positive return value and negative fibrational component
\end{enumerate}

Programs have a few operations:
\begin{enumerate}
  \item Write, of course. We will write it as $a^{+} \mapsto a^{-}$.
  \item Done, which is necessary for the grammar to be right-associative. We will write it as $\emptyset$.
  \item Borrow, which abstracts over an opaque value of a wire. We do not need this yet, so we omit it. We may also restrict it to borrowing variables only, as opposed to generate negative terms.
  \item Pair, which bundles up two wires (with a type dependency) into a sigma-wire. This can be implemented in user-land: $(a^{-}, b^{-}) := \lambda ab \to (\Fst{ab} \mapsto a^{-}); (\Snd{ab} \mapsto b^{-})$.
  \item Unpack, which splits a sigma-wire into two wires (with a type dependency). We will write it as $v^{-} \prec (x^{-}, y^{-})$.
  \item Morphism application can also be implemented in user-land (although it loses sharing but eh we don't have that anyways).
\end{enumerate}

Linearity is checked by writing a negative variable's written value in context, never allowing it to be written twice, and checking that all variables have been written by the end of a morphism-body.

Writing a variable only occurs in negative terms in programs and morphism bodies.
This introduces additional definitional equalities for $\Borrow a^{-}$ into scope.
Namely, $a \mapsto x^{-} : A$ allows for the reduction $\Borrow x^{-} \equiv a$.

\begin{mathpar}
  \inferrule[\Deriv{Borrow-reduce}] {
  } {
    \Gamma \mid \Psi \mid \chi_L, (a \mapsto x^{-} : A^{-}), \chi_R \vdash \Borrow x^{-} \equiv a : A
  }
\end{mathpar}

TODO: what to do about compound negative terms? disallow them?

Negative terms in negative types are not consumed.
In particular, mentioning a negative variable in $\Borrow a^{-}$ does not consume it, so this means that the only difference between types and negative types are that the latter may mention $\Borrow a^{-}$.

\begin{mathpar}
  \inferrule[\Deriv{Borrow-negative}] {
    \Gamma \mid \Psi \vdash a^{-} : A^{-}
  } {
    \Gamma \mid \Psi \vdash \Borrow a^{-} : A
  }
\end{mathpar}

This means that the MLTT fragment does not need to care about linearity.
It only needs to pass along the compound context $\Gamma \mid \Psi$.
For example, the application rule looks like this:

\begin{mathpar}
  \inferrule[\Deriv{Ap}] {
    \Gamma \mid \Psi \vdash f : (a : A) \to B[a]\\
    \Gamma \mid \Psi \vdash v : A
  } {
    \Gamma \mid \Psi \vdash f(v) : B[v]
  }
\end{mathpar}

It would be nice to get rid of the morphism-body, since various judgments are polymorphic over it in their return (e.g. sequencing and negsima-elim), but let's gloss over that for now.
Sequencing is right-associative: each statement may bind variables and write values that appear in all following statements.
In fact that needs to be baked into the syntax, so that the environment can remain a reader context.

%\begin{mathpar}
%  \inferrule[\Deriv{Seq-Program}] {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi_1}\\
%    \Gamma \mid \Psi \mid {\downarrow \pi_1}; \chi \vdash \IsProg{\pi_2}
%  } {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi_1 ; \pi_2}
%  }
%\end{mathpar}
%\begin{mathpar}
%  \inferrule[\Deriv{Seq-Body}] {
%    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\pi}\\
%    \Gamma \mid \Psi \mid {\downarrow \pi}; \chi \vdash \rho :\Rightarrow Q
%  } {
%    \Gamma \mid \Psi \mid \chi \vdash \pi ; \rho :\Rightarrow Q
%  }
%\end{mathpar}



\section{Negative contexts and types}

Negative contexts have variables of specified negative types.
Negative types are exactly regular types with access to $\Borrow{x^{-}}$ for all negative variables $x^{-}$ in scope thus far, so we omit its derivation rules.

\begin{mathpar}
  \inferrule[\Judg{Neg-ctx}] {
    \IsCtx{\Gamma}
  } {
    \Gamma \vdash \IsNegCtx{\Psi}
  }

  \inferrule[\Judg{Neg-type}] {
  	\IsCtx{\Gamma}\\
    \Gamma \vdash \IsNegCtx{\Psi}
  } {
    \Gamma \mid \Psi \vdash \IsTp{A^{-}}
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[\Deriv{Neg-ctx-empty}] {
  	\IsCtx{\Gamma}
  } {
    \Gamma \vdash \IsNegCtx{\cdot}
  }

  \inferrule[\Deriv{Neg-ctx-snoc}] {
    \Gamma \vdash \IsNegCtx{\Psi}\\
    \Gamma \mid \Psi \vdash \IsTp{A^{-}}
  } {
    \Gamma \vdash \IsNegCtx{\Psi, x^{-} : A^{-}}
  }
\end{mathpar}



\section{Negative terms and programs and program environments}

Programs are exactly the bodies of eta-expanded negative terms:

\begin{mathpar}
  \inferrule[\Deriv{Neg-Eta}] {
    \Gamma, a : A \mid \Psi \mid \chi \vdash \IsProg{\pi}
  } {
    \Gamma \mid \Psi \mid \chi \vdash (\lambda a \to \pi) : A^{-}
  }
\end{mathpar}

Note that $a$ cannot depend on any negative terms (in particular, cannot borrow).
That means that $a^{-}$ needs its type $A^{-}$ to reduce to a term that does not mention borrowed values, either by having no dependence on other sinks in the first place or by already being written to a value from previous writes in $\chi$.

\begin{mathpar}
  \inferrule[\Deriv{Neg-Write}] {
    \Gamma \vdash a : A\\
    \Gamma \mid \Psi \mid \chi \vdash a^{-} : A^{-}\\
    \Gamma \mid \Psi \mid {\downarrow (a \mapsto a^{-})}; \chi \vdash \IsProg{\pi}
  } {
    \Gamma \mid \Psi \mid \chi \vdash \IsProg{(a \mapsto a^{-}); \pi}
  }
\end{mathpar}

Program environments write variables in LtR order, but are constructed RtL.

Operationally, we think of them as operating on mutable cells corresponding to each variable in scope.
These cells are initialized with $\Borrow{self}$ and written to in order to trace out the reverse direction of poly morphisms.

\begin{mathpar}
  \inferrule[\Judg{Neg-env}] {
    \Gamma \vdash \IsNegCtx{\Psi}
  } {
    \Gamma \mid \Psi \vdash \IsNegEnv{\chi}
  }
\end{mathpar}

Their scoping is a bit weird, since they can depend on any variables in $\Psi$ (and are stable under weakening = adding variables to $\Psi$).
Note that, unlike $\textsc{\Deriv{Neg-Set}}$, their value \emph{can} depend on further borrows! (And definitional equalities introduced into the environment already.)
The only place we use this affordance is in $\textsc{\Deriv{Unpack}}$.

\begin{mathpar}
  \inferrule[\Deriv{Neg-env-empty}] {
    \Gamma \vdash \IsNegCtx{\Psi}
  } {
    \Gamma \mid \Psi \vdash \IsNegEnv{\emptyset}
  }
\end{mathpar}
\begin{mathpar}
  \inferrule[\Deriv{Neg-env-cons}] {
    \Gamma \mid \Psi \vdash \IsNegEnv{\chi}\\
    x^{-} \notin \chi\\
    \Gamma \mid \Psi \vdash \IsTp{A^{-}}\\
    \Gamma \mid \Psi \mid \chi \vdash a : A\\
  } {
    \Gamma \mid \Psi \vdash \IsNegEnv{(a \mapsto x^{-} : A^{-}); \chi}
  }
\end{mathpar}

The linearity check is ensured by never writing to the same variable twice and by checking that each variable in $\Psi$ is written exactly once by the end of the hom-body:
\begin{mathpar}
  \inferrule[\Deriv{Neg-env-filled}] {
  	Vars(\Psi) = Vars(\chi)
  } {
    \Psi \cong \IsFilled{\chi}
  }
\end{mathpar}
In particular, this is used for program extraction of the backwards action on fibrations, by seeing what the input $p^{-}$ is set to in the environment.

TODO: check no cycles introduced.

\begin{mathpar}
  \inferrule[\Deriv{Borrowing}] {
    x^{-} \notin \chi\\
    \Gamma \mid \Psi \mid \chi \vdash x^{-} : A^{-}\\
  	\Gamma, y : A \mid \Psi \mid (y \mapsto x^{-} : A^{-}); \chi \vdash \IsProg{\pi_1[y]}\\
  	\Gamma \mid \Psi \mid {\downarrow (\pi_1[\Borrow{x^{-}}])}; \chi \vdash \IsProg{\pi_2}\\
  } {
    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\Borrow{x^{-}} \in (\lambda y \to \pi_1[y]); \pi_2}
  }
\end{mathpar}

Note that we have to borrow against a negative \emph{variable}, since we keep record of their cells and we cannot in general hope to invert general negative terms.
(Note also that we can borrow a variable that is already set in $\chi$, by positive let-binding it.)
However, we can allocate new cells through a negative let-binding:

\begin{mathpar}
  \inferrule[\Deriv{Lending??}] {
    \Gamma \mid \Psi \mid \chi \vdash a^{-} : A^{-}\\
    \Gamma \mid \Psi, x^{-} : A^{-} \mid {\downarrow (\Borrow{x^{-}} \mapsto a^{-})}; \chi \vdash \IsProg{\pi_2}
  } {
    \Gamma \mid \Psi \mid \chi \vdash \IsProg{\Let{x^{-}} : A^{-} := a^{-}; \pi_2}
  }
\end{mathpar}




\section{Morphism body}

This provides the forward component $p^{+}$ and adds an obligation $p^{-}$, then checks that the body of the morphism $\rho$ will fulfill the obligation.

\begin{mathpar}
  \inferrule[\Deriv{Morph-Intro}] {
    \Gamma, p^{+} : \Base{P} \mid p^{-} : \Fib{P}{p^{+}} \mid \emptyset \vdash \rho :\Rightarrow Q\\
  } {
    \Gamma \vdash (\lambda p^{+} p^{-} \rightsquigarrow \rho) : P \Rightarrow Q
  }
\end{mathpar}

The obligation is fulfilled when the body ends, providing a positive value for the base and a negative sink for the fibration, and every negative variable in $\Psi$ has been set to a positive value in $\chi$.

\begin{mathpar}
  \inferrule[\Deriv{Body-Done}] {
    \Gamma \vdash q^{+} : \Base{Q}\\
    \Gamma \mid \Psi \vdash q^{-} : (\Fib{Q}{q^{+}})^{-}\\
    \Psi \cong \IsFilled{(q \mapsto q^{-}); \chi}
  } {
    \Gamma \mid \Psi \mid \chi \vdash (q^{+} \leftsquigarrow q^{-}) :\Rightarrow Q
  }
\end{mathpar}

The action on fibrations can be recovered as something like $\lambda q. p$ where $\Gamma, p^{+} : \Base{P}, q^{+} : \Base{Q} \mid p^{-} : \Fib{P}{p^{+}} \mid (q \mapsto q^{-}) : \Fib{Q}{q^{+}}, (p \mapsto p^{-}) : \Fib{P}{p^{+}}$, where $p^{-}$ gets set to $p$ in the process of setting $q^{-}$ to $q$.



\section{Sigmas}

Consumes $ab^{-}$, splitting it into two new wires $(x^{-}, y^{-})$ whose values get paired and written to $ab^{-}$.

\begin{mathpar}
  \inferrule[\Deriv{Unpack}] {
    \Gamma \mid \Psi \mid \chi_1 \vdash ab^{-} : (a : A) \times B^{-}[a]\\
    \chi_2 := {\downarrow ((\Borrow{x^{-}}, \Borrow{y^{-}}) \mapsto ab^{-})}; \chi_1 \\
    \Gamma \mid \Psi, x^{-} : A^{-}, y^{-} : B^{-}[\Borrow{x^{-}}] \mid \chi_2 \vdash \IsProg{\pi}\\
  } {
    \Gamma \mid \Psi \mid \chi_1 \vdash ab^{-} \prec (x^{-}, y^{-}); \IsProg{\pi}
  }
\end{mathpar}




\end{document}