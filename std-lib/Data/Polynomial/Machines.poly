import Data::Bool
import Data::Either
import Data::Natural
import Data::Unit
import Data::Polynomial
import Data::Polynomial::List

--------------------------------------------------------------------------------

-- | Moore Machines
--
-- â–†  If ğ´, ğµ, and ğ‘† are sets, an (ğ´, ğµ)-Moore machine with
-- â”‚  states ğ‘† consists of two functions
-- â”‚    return : ğ‘† â†’ ğµ
-- â”‚    update : ğ‘† Ã— ğ´ â†’ ğ‘†
--
-- An AB-Moore Machine is simply morphism between monomials:
--
--   SyË¢ â‡’ Byá´¬
def Moore : Type â†’ Type â†’ Type â†’ Type :=
  Î» S I O â†’ (S Ã— y^S) â‡’ (O Ã— y^I)

-- | Build a 'Moore' machine from return and update functions.
def moore : Î (S I O : Type), (S â†’ O) â†’ (S â†’ I â†’ S) â†’ Moore S I O :=
  Î» S I O output transition â†’
    Î» sâº â‡œ sâ» â‡’
      return (output sâº) â‡œ sâ» âˆ˜ (transition sâº)

def disassemble-moore : Î  (S I O : Type), Moore S I O â†’ (S â†’ O) Ã— (S â†’ I â†’ S) :=
  Î» S I O moore â†’
    (Î» s â†’ fst (moore s) , Î» s â†’ snd (moore s) )

-- | Given an input 'I' and a state 'S', execute one step of a 'Moore'
-- | machine emitting:
--     - The observation 'O' at the initial state.
--     - A new  state generated from the input and initial state.
def step-moore : Î (S I O : Type), I â†’ S â†’ Moore S I O â†’ (O Ã— S) :=
  Î» S I O i s machine â†’
    let observe := hom-base (S Ã— y^S) (O Ã— y^I) machine in
    let transition := hom-fiber (S Ã— y^S) (O Ã— y^I) machine in
    ( observe s , transition s i )

-- | Given an initial state 'S' and a list of inputs 'List I', run the
-- | 'Moore' machine on all the sequential inputs returning a list of
-- | outputs and states.
--
-- TODO: Return a Vector of outputs and a single final state.
def process-moore : Î (S I O : Type), S â†’ List I â†’ Moore S I O â†’ List (O Ã— S) :=
  Î» S I O s xs machine â†’
    list-rec
      I
      (List (O Ã— S))
      (Nil (O Ã— S))
      (Î» a acc â†’ let os := step-moore S I O a s machine in Cons (O Ã— S) os acc)
      xs

--------------------------------------------------------------------------------

-- An AB-Mealy Machine is simply morphism between monomials:
--
--   SAyË¢ â‡’ By^Unit
def Mealy : Type â†’ Type â†’ Type â†’ Type :=
  Î» S I O â†’ ((S Ã— I) Ã— y^S) â‡’ (O Ã— y^Unit)

-- | Build a 'Mealy' machine from a transition function.
def mealy : Î (S I O : Type), ((S Ã— I) â†’ (S Ã— O)) â†’ Mealy S I O :=
  Î» S I O transition â†’
    Î» siâº â‡œ siâ» â‡’
      return snd (transition siâº) â‡œ Î»â» (_ : Unit) â†’ siâ» â† fst (transition siâº); done

-- | Given an input 'I' and a state 'S', execute one step of a 'Mealy'
-- | machine emitting:
--     - The observation 'O' at the initial state and input.
--     - A new  state generated from the input and initial state.
def step-mealy : Î (S I O : Type), I â†’ S â†’ Mealy S I O â†’ (O Ã— S) :=
  Î» S I O i s machine â†’
    let observe := hom-base ((S Ã— I) Ã— y^S) (O Ã— y^Unit) machine in
    let transition := hom-fiber ((S Ã— I) Ã— y^S) (O Ã— y^Unit) machine in
    (observe  (s , i), transition (s , i) .unit)

-- | Given an initial state 'S' and a list of inputs 'List I', run the
-- | 'Mealy' machine on all the sequential inputs returning a list of
-- | outputs and states.
--
-- TODO: Return a Vector of outputs and a single final state.
def process-mealy : Î (S I O : Type), S â†’ List I â†’ Mealy S I O â†’ List (O Ã— S) :=
  Î» S I O s xs machine â†’
    list-rec
      I
      (List (O Ã— S))
      (Nil (O Ã— S))
      (Î» a acc â†’ let os := step-mealy S I O a s machine in Cons (O Ã— S) os acc)
      xs

--------------------------------------------------------------------------------

-- | We can convert any 'Moore' to a 'Mealy'
def Mooreâ†’Mealy : Î (S I O : Type), Moore S I O â†’ Mealy S I O :=
  Î» S I O moore â†’
    let output : S â†’ O := hom-base (S Ã— y^S) (O Ã— y^I) moore in
    let transition : S â†’ I â†’ S := hom-fiber (S Ã— y^S) (O Ã— y^I) moore in
    Î» siâº â‡œ siâ» â‡’
      return (output (fst siâº)) â‡œ Î»â» (_ : Unit) â†’ siâ» â† transition (fst siâº) (snd siâº); done

-- | We can convert any 'Mealy' to an awkward 'Moore'
def Mealyâ†’Moore : Î (S I O : Type), Mealy S I O â†’ Moore (S Ã— I) I O :=
  Î» S I O mealy â†’
    let output : ((S Ã— I) â†’ O) := (hom-base ((S Ã— I) Ã— y^S) (O Ã— y^Unit) mealy) in
    let transition : (S Ã— I) â†’ Unit â†’ S := hom-fiber ((S Ã— I) Ã— y^S) (O Ã— y^Unit) mealy in
    Î» sâº â‡œ sâ» â‡’
      return output sâº â‡œ Î»â» (i : I) â†’ sâ» â† (transition sâº unit, i) ; done

--------------------------------------------------------------------------------
-- Examples

-- | Determinisitic Finite State Automata. The output 'Bool'
-- determines the accept states.
--
-- SyË¢ â‡’ 2yáµƒ
--
--  S Ã— S â‡’ Bool Ã— A
def DFSA : Type â†’ Type â†’ Type :=
  Î» S A â†’ Moore S A Bool

-- | A memoryless dynamical system
--
-- B Ã— y^B â‡’ B Ã— y^A
def mds : Î  (A B : Type), (A â†’ B) â†’ Moore B A B :=
  Î» A B f â†’
    Î» bâº â‡œ bâ» â‡’
      return bâº â‡œ bâ» âˆ˜ f

-- | A mealy encoding of a memoryless dynamical system
def mds-mealy : Î (A B : Type), (A â†’ B) â†’ Mealy Unit A B :=
  Î» A B f â†’
    Î» (_ , iâº) â‡œ siâ» â‡’
      return f iâº â‡œ siâ»

-- | An MDS given a partial function.
--
-- (1 + B) Ã— y^(1 + B) â‡’ (1 + B) Ã— y^A
def mds-partial : Î  (A B : Type),
  (A â†’ Either Unit B) â†’
  Moore (Either Unit B) A (Either Unit B) :=
  Î» A B f â†’
    Î» bâº â‡œ bâ» â‡’
      return bâº â‡œ Î»â» (a : A) â†’ bâ» â† (bind-either Unit B B (Î» _ â†’ f a) bâº); done

-- | Delay receives an 'A' as input, sets the state to it, and outputs
--   the prior state 'A'.
--
--     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--    -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
--   â”€â”€â”¼â”€â”€â”€â”¤   â”œâ”€â”€â”€â”¼â”€â”€
--     â”‚   â””â”€â”€â”€â”˜   â”‚ 
--     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--
-- A Ã— y^A â‡’ A Ã— y^A
def delayâ‚˜ : Î (A : Type), Moore A A A :=
  Î» A â†’ mds A A (Î» x â†’ x)

-- | Sum receives a pair of â„• as input and outputs their sum.
--
--     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--    -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
--   â”€â”€â”¼â”€*â”€â”¤â„• â„•â”œâ”€â”€â”€â”¼â”€â”€
--  â„•Ã—â„•â”‚   â””â”€â”€â”€â”˜   â”‚â„•
--     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--  Note at * we apply the addition operation
--
-- â„• Ã— y^â„• â‡’ â„• Ã— y^(â„• Ã— â„•)
def sumâ‚˜ : Moore â„• (â„• Ã— â„•) â„• :=
  mds (â„• Ã— â„•) â„• (Î» (x , y) â†’ add x y)

-- | Counter receives a 'Unit' and outputs the sequence of natural
-- numbers 0, 1, 2, 3, ... .
--
--     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--    -â”‚  -â”Œâ”€â”€â”€â”+   â”‚+
--   â”€â”€â”¤  â”Œâ”¤ â„• â”œâ”¬â”€â”€â”€â”¼â”€â”€
--   ()â”‚  â”‚â””â”€â”€â”€â”˜â”‚   â”‚â„•
--     â”‚  â””â”€â”€*â”€â”€â”˜   â”‚
--     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--     Note: At * we apply 'succ'
--
--  â„• Ã— y^â„• â‡’ â„• Ã— y^Unit
def counterâ‚˜ : Moore â„• Unit â„• :=
  moore â„• Unit â„• (Î» a â†’ a) (Î» n _ â†’ succ n)

-- #normalize (step-moore â„• Unit â„• .unit 0 counter)

-- | Repeater receives a Unit and outputs its state.
--
--     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--    -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
--   â”€â”€â”¤   â”‚ â„• â”œâ”€â”€â”€â”¼â”€â”€
--   ()â”‚   â””â”€â”€â”€â”˜   â”‚â„•
--     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--     Note: At * we apply 'succ'
--
--  â„• Ã— y^â„• â‡’ â„• Ã— y^Unit
def repeaterâ‚˜ : Moore â„• Unit â„• :=
  moore â„• Unit â„• (Î» x â†’ x) (Î» n _ â†’ n)

-- #normalize (step-moore â„• Unit â„• .unit 42 repeater)
