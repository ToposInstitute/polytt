import Data::Polynomial
import Data::Polynomial::Machines
import Data::Natural

--------------------------------------------------------------------------------
-- *** WORK IN PROGRESS ***
--
-- This is an introductory tutorial assuming an understanding of MLTT
-- and some degree of exposure to Poly.

--------------------------------------------------------------------------------
-- | MLTT Syntax

-- PolyTT is a full Martin-Lof Type Theory with special primitives for
-- Polynomials.

-- | Naturals are defined recursively and implemented as a primitive:
def one : â„• := 1
def two : â„• := succ one

-- | Equality
def oneâ‰¡one : one = 1 := refl

-- | Pi Types:
def id : Î  (A : Type), A â†’ A := Î» A a -> a

-- | Sigma Types:
def Vec : Type â†’ Type :=
  Î» A â†’ Î£(n : â„•), fin n â†’ A

-- | Finite Sets:
def RGB : Type := #{ .Red, .Green, .Blue }

-- | Finite Set case elimination:
def rgb-func : RGB â†’ â„• :=
  { .Red = 0
  , .Green = 1
  , .Blue = 2
  }

-- | Typeholes are defined with a question mark. Uncomment to test:
--
-- NOTE: In Poly-Lambdas typeholes are limited to positive positions.
-- def type-hole : â„• := ?

--------------------------------------------------------------------------------
-- | Polynomials

-- Polynomials are encoded as Sigma types of the form:
--
-- (base : Type, fiber : base â†’ Type)
--
-- Projection functions 'base' and 'fiber' are provided.

-- | P(y) â‰” yÂ²
def P : Poly :=
  Î£(_ : Unit), y^(fin 2)

-- | Q(y) â‰” yÂ³ + yÂ²
def Q : Poly :=
  -- NOTE: We use FiniteSets rather then inductive 'Fin' here because
  -- elmination of 'Fin' is very painful at the moment.
  Î£(i : #{ .zero, .one }),
    y^(
      { .zero = fin 3
      , .one = fin 2
      } i
    )

-- R(y) â‰” yÂ³ + yÂ² + y + 1
--
-- R(y) â‰” Î£(i : Fin 4), y^(Fin 4)
def R : Poly :=
  Î£(i : #{ .zero, .one, .two, .three}),
    y^(
      { .zero = fin 3
      , .one = fin 2
      , .two = fin 1
      , .three = fin 0
      } i
    )

def Listâ‚š : Poly :=
  Î£(n : â„•), y^(fin n)

-- | â„•y^â„•
def nyan : Poly :=
  Î£(_ : â„•), y^â„•

-- | We can also define a non-dependent Poly using product shorthand
-- in place of Sigma:
def nyan' : Poly := â„• Ã— y^â„•

-- | We can then prove their equivalence:
def sigmaâ‰¡pair : nyan = nyan' := refl

-- | S Ã— Xâ°
def constant : Î (S : Type), Poly :=
  Î» S â†’ S Ã— y^(fin 0)

--------------------------------------------------------------------------------
-- | Morphisms in Poly
--
-- The type of morphisms in Poly is denoted with the _â‡’_ arrow:

def poly-map : Î (P Q : Poly), Type :=
  Î» P Q â†’ P â‡’ Q

-- A Poly morphisms 'P â‡’ Q' consist of:
--
--   1. mapáµ‡ : base P â†’ base Q
--   2. mapá¶  : Î (p : base P), fib Q (mapáµ‡ p) â†’ fib P p
--
-- These are bundled in a Sigma type:
--
--   Î£(mapáµ‡ : base P â†’ Base Q), (Î (p : base p), fib Q (mapáµ‡ p) â†’ fib P p)
--
-- Notice how both projections of the Sigma receive a 'base P'. In the
-- PolyTT implementation, we factor out this 'base P' and rewrite our
-- Poly morphism as:
--
--   Î (p : base P), Î£(q : base Q), (fib Q q â†’ fib P p)
--
-- This reshuffing is equivalent to the isomorphism between 'A â†’ (B,
-- C)' and '(A â†’ B, A â†’ C)'. This variation on the typical Poly
-- morphism encoding becomes important with Poly-Lambda syntax.

-- We will start by defining a few basic morphisms in the direct Pi
-- over Sigma style as you would in Agda.

-- | The identity morphism maps P to P.  
def id : Î (P : Poly), P â‡’ P :=
  Î» P b â†’ (b , Î» x â†’ x)

-- | Ayâ° â‡’ Byâ°
def const : Î (A B : Type), (A â†’ B) â†’ (A Ã— y^(fin 0)) â‡’ (B Ã— y^(fin 0)) :=
  Î» A B f a â†’ (f a , Î» x â†’ x)

-- | yá´® â‡’ yá´¬
def rep : Î (A B : Type), (A â†’ B) â†’ (fin 1 Ã— y^B) â‡’ (fin 1 Ã— y^A) :=
  Î» A B f a â†’ (z 0 , f)

-- | P â‡’ p(1)
def pâ‡’p1 : Î (P : Poly), P â‡’ (base P Ã— y^Void) :=
  Î» P p â†’ ( p , absurd (fib P p)) 

-- | AyÂ¹ â‡’ ByÂ¹
def linear : Î (A B : Type), (A â†’ B) â†’ (A Ã— y^(fin 1)) â‡’ (B Ã— y^(fin 1)) :=
  Î» A B f b â†’ (f b , Î» x â†’ x)

--------------------------------------------------------------------------------
-- | Poly-Lambda Syntax
--
-- We provide a special form of lambda syntax for defining morphisms
-- in Poly. This allows you to bind the forward map on bases and
-- backwards map on fiber's (which we call a fiber-sink) of
-- polynomials, and connect them in a typesafe manner.
--
-- We declare a Poly-Lambda with a specialized lambda syntax:
--
--  Î» (domainâº â‡œ domainâ») â‡’
--
-- Where '(dom-base â‡œ dom-fib)' respectively binds the base and fiber-sink of the
-- domain polynomial.
--
-- We then complete the Poly-Lambda by describing how to wire the
-- codomain polynomial using a 'return' statement:
--
--  return cod-base â‡œ cod-fib
--
-- where 'cod-base â‡œ cod-fib' applies 'cod-base' and 'cod-fib'
-- variables as the base and fiber of the codomain polynomail.
--
-- Between the lambda declaration and return statement we can use
-- various bits of special syntax to manipulate and 'wire' the
-- Poly-Lambda. This syntax will be introduced gradually in this
-- section.
--
-- For a first example we can re-implement idâ‚š using just the basic
-- Poly-Lambda syntax.
--
-- As a wiring diagram, idâ‚š looks like:
--
--         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--        -â”‚ -â”Œâ”€â”€â”€â”+ â”‚+
-- idâ‚š : â”€â”€â”¼â”€â”€â”¤  *â”œâ”€â”€â”¼â”€â”€
--         â”‚  â””â”€â”€â”€â”˜**â”‚
--         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--         *  domain
--         ** codomain
--
-- Where + denotes the base and - denotes the fiber-sink. Being the
-- identity morphism, 'idâ‚š' maps from 'base P' to 'base P' and 'fib P'
-- to 'fib P'.

def id : Î (P : Poly), P â‡’ P :=
  Î» P â†’
    -- Here we bind the base and fiber-sink of the domain Poly:
    -- domainâº : base P
    -- domainâ» : fib P domainâº â†’ _
    Î» (domainâº â‡œ domainâ») â‡’
    -- And here we define the base and fiber-sink of the codomain
    -- Poly. In this case we map the base to the base and the
    -- fiber-sink to the fiber-sink.
    return domainâº â‡œ Î»â» codomain-fiber â†’ domainâ» â† codomain-fiber ; done

-- For reference here we re-implement all the previously defined
-- morphisms using Poly-Lambda syntax:

-- Ayâ° â‡’ Byâ°
def const : Î (A B : Type), (A â†’ B) â†’ (A Ã— y^(fin 0)) â‡’ (B Ã— y^(fin 0)) :=
  Î» A B f â†’ 
    Î» pâº â‡œ pâ» â‡’
      return f pâº â‡œ pâ»

-- yá´® â‡’ yá´¬
def rep : Î (A B : Type), (A â†’ B) â†’ (fin 1 Ã— y^B) â‡’ (fin 1 Ã— y^A) :=
  Î» A B f â†’
    Î» pâº â‡œ pâ» â‡’
      return z 0 â‡œ pâ» âˆ˜ f

-- | P â‡’ P(1)
def pâ‡’p1 : Î (P : Poly), P â‡’ (base P Ã— y^Void) :=
  Î» P â†’ 
    Î» pâº â‡œ pâ» â‡’
      return pâº â‡œ pâ» âˆ˜ (absurd (fib P pâº))

-- | AyÂ¹ â‡’ ByÂ¹
def linear : Î (A B : Type), (A â†’ B) â†’ (A Ã— y^(fin 1)) â‡’ (B Ã— y^(fin 1)) :=
  Î» A B f â†’ 
    Î» pâº â‡œ pâ» â‡’
      return f pâº â‡œ pâ»

-- | _â†_ Notation
--
-- In more complicated morphisms you start to require internal
-- connections across tensored polynomials or to produce feedback
-- loops around polynomials.
--
-- The _â†_ notation allows for these sorts of internal connections
-- within Poly-Lambda syntax:
--
--   q-fiber â† p-base;
--
-- From the wiring diagram perspective, a wire has been drawn
-- connecting 'p-base' to 'q-fiber'.
--
-- Operationally this means we have applied 'p-base' to 'mapáµ‡' to
-- produce a 'base Q' and applied it to the 'fiber Q'.
--
-- For example, we can demonstrate a simple feedback loop on the inner
-- (domain) Poly by implementing a counter:
--
--              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--	       -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
-- counterâ‚š : â”€â”€â”¤  â”Œâ”¤ â„• â”œâ”¬â”€â”€â”¼â”€â”€
--            ()â”‚  â”‚â””â”€â”€â”€â”˜â”‚  â”‚â„•
--              â”‚  â””â”€â”€*â”€â”€â”˜  â”‚
--              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--              Note: At * we apply 'succ'
--
-- Here the outer (codomain) Poly receives a unit value, which we
-- discard, and the inner Poly emits a â„• which is fanned out to both
-- the base of the outer Poly and back to the fiber-sink of the inner
-- Poly.
--
-- For this machine we will need to introduce two concepts:
--
-- 1. A special syntax element for the unique sink--which we call
--    'drop'--which does nothing with its input. The syntax for drop
--    is a '!' character.
--
-- 2. Applying a function to the base of the inner Poly.
--
--    Whenever we are in a positive position (the base) we have a
--    value and can apply a function to it. In this case we apply
--    'succ' to the base in the feedback loop to increment the
--    counter.

def counter : (â„• Ã— y^â„•) â‡’ (â„• Ã— y^Unit) :=
  -- Bind the base and fiber-sink of the inner Poly:
  -- nâº : base (â„• Ã— â„•)
  -- nâ» : fib (â„• Ã— â„•) nâº
  Î» nâº â‡œ nâ» â‡’

    -- Apply 'succ' to nâº and connect it back to nâ» to create the
    -- feedback loop:
    nâ» â† succ nâº;

    -- Drop the fiber-sink from the outer Poly and connect nâº to its
    -- base.
    return nâº â‡œ !

-- Uncomment to demo the counter:
-- #normalize (step-moore â„• Unit â„• .unit 2 counterâ‚š)

def counter' : (â„• Ã— y^â„•) â‡’ (â„• Ã— y^Unit) :=
  Î» n â†’ ( n , Î» _ â†’ succ n )

def counterâ‰¡counter : counter = counter' := refl

-- | Let Notation
--
-- Let bindings allow you to apply a 'base' to a Poly morphisms inside
-- a Poly-Lambda and bind the resulting components.
--
-- We can do this because we have internally enocoded our morphisms
-- as:
--
--   Î (p : base P), Î£(q : base Q), (fib Q q â†’ fib P p)
--
-- By applying a 'base P' to the morphism, we simply return a pair of
-- a 'base Q' and the 'fib Q _ â†’ fib P _' map which we bind to variables:
--
--   let (qâº , fâ») := f pâº;
--
-- With types:
--
--   qâº : base Q
--   fâ» : fib Q (mapáµ‡ pâº) â†’ fib P pâº'.
--
-- 
-- Let comes in positive and negative forms which allow you to apply
-- the base and fiber-sink components of Poly morphisms respectively.
--
-- Eg., Given 'pâº : base P' and 'pâ» : fib P pâº':
--
--    -- Apply our 'pâº : base P' to the morphism 'P â‡’ Q' and project
--    -- out the fst component 'qâº : base Q'
--    let qâº := fst (g pâº);
--
--    -- Apply our 'pâº : base P' to the morphism 'P â‡’ Q' and project
--    -- out the snd component 'g_fib : fib Q qâº â†’ fib P pâº'
--    let g_fib := snd (g pâº);
--
--    -- Remember here that when in a negative position we are dealing
--    -- with sinks which expect values rather then produce them. Thus
--    -- we need to think about 'pâ»' as an obligation to produce a
--    -- 'fib P pâº'.
--    --
--    -- In a negative fragment _âˆ˜_ is special syntax for
--    -- precomposition with sinks. pâ» is an obligation to provide a
--    -- 'fib P pâº' and it is precomposed with 'g_fib' which is a
--    -- function which maps a 'fib Q qâº' to a 'fib P pâº'.
--    -- 'qâ»' is thus an obligation to provide a 'fib Q qâº.
--    let- qâ» := pâ» âˆ˜ g_fib;
--
-- Composition of Poly morphisms serves as a good example of let bindings:
--
--   compose : Î  (P Q R : Poly), (Q â‡’ R) â†’ (P â‡’ Q) â†’ (P â‡’ R)
--
-- First lets build an intuition for composition in Poly using wiring
-- diagrams:
--
-- Given 'g : P â‡’ Q' and 'f : Q â‡’ R':
--
--          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--         -â”‚ -â”Œâ”€â”€â”€â”+ â”‚+
--   g :  â”€â”€â”¼â”€â”€â”¤  Pâ”œâ”€â”€â”¼â”€â”€â”€
--          â”‚  â””â”€â”€â”€â”˜ Qâ”‚
--          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--
--          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--         -â”‚ -â”Œâ”€â”€â”€â”+ â”‚+
--   f :  â”€â”€â”¼â”€â”€â”¤  Qâ”œâ”€â”€â”¼â”€â”€â”€
--          â”‚  â””â”€â”€â”€â”˜ Râ”‚
--          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--
-- We define composeâ‚š as:
--
--               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
--              -â”‚ -â”‚ -â”Œâ”€â”€â”€â”+ â”‚+ â”‚+
--   compose : â”€â”€â”¼â”€â”€â”¼â”€â”€â”¤  Pâ”œâ”€â”€â”¼â”€â”€â”¼â”€â”€
--               â”‚  â”‚  â””â”€â”€â”€â”˜ Qâ”‚  â”‚
--               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Râ”‚
--               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--
-- You can think of composeâ‚š as building a Matryoshka doll of
-- polynomials where the middle Poly Q is an interface translation
-- layer between the inner and outer Polys. This will become clear
-- when we look at wiring diagrams later.
--
-- Starting from our inner 'P : Poly' we use let and let- to apply our
-- Poly morphisms and build up to a 'base R' and obligation 'fib R
-- (base R)':

def compose : Î (P Q R : Poly), (Q â‡’ R) â†’ (P â‡’ Q) â†’ (P â‡’ R) :=
  Î» P Q R f g â†’
    Î» pâº â‡œ pâ» â‡’
      let (qâº , gâ») := g pâº;
      let- qâ» := pâ» âˆ˜ gâ»;

      let (râº , fâ») := f qâº;
      let- râ» := qâ» âˆ˜ fâ»;

      return râº â‡œ râ»

def compose : Î (P Q R : Poly), (Q â‡’ R) â†’ (P â‡’ Q) â†’ (P â‡’ R) :=
  Î» P Q R f g â†’
    Î» pâº â‡œ pâ» â‡’
      let (qâº , gâ») := g pâº;
      let- qâ» := pâ» âˆ˜ gâ»;

      let (râº , fâ») := f qâº;
      let- râ» := qâ» âˆ˜ fâ»;

      return (fst (f (fst (g pâº)))) â‡œ Î»â» r â†’
        râ» â† r ; done

-- For reference, compose can be defined as follows without poly-lambda syntax:

def compose' : Î (P Q R : Poly), (Q â‡’ R) â†’ (P â‡’ Q) â†’ (P â‡’ R) :=
  Î» P Q R f g pâº â†’
    let (qâº , qâ») := g pâº in
    let (râº , râ») := f qâº in
    (râº , Î» r â†’ qâ» (râ» r))

def compose-equiv : compose = compose' := refl

-- We provide a special _â‡œ_ syntax to streamline this use of let
-- bindings. It allows you to apply an entire Poly to a morphism and
-- bind both projections of the resulting Poly.
--
-- These two fragments are thus equivalent:
--
--    let (qâº â‡œ qâ») := g (pâº â‡œ pâ»);
--
--    let (qâº , gâ») := g pâº;
--    let- qâ» := pâ» âˆ˜ gâ»;
--
-- We can simplify composeâ‚š as such:

def compose' : Î (P Q R : Poly), (Q â‡’ R) â†’ (P â‡’ Q) â†’ (P â‡’ R) :=
  Î» P Q R f g â†’ Î» pâº â‡œ pâ» â‡’
    let (qâº â‡œ qâ») := g (pâº â‡œ pâ»);
    let (râº â‡œ râ») := f (qâº â‡œ qâ»);
    return râº â‡œ râ»

-- We can prove the equivalence of these two definitions:
-- def compose-equiv : composeâ‚š = composeâ‚š' := refl

-- | Working with tensors
--
-- In the case of tensor products, we provide a special syntax for
-- splitting apart the inlets of tensored polynomials.
--
-- Given a 'P âŠ— Q':
--
--   let (pâº , qâº) := pqâº;
--   letâ» (pâ» , qâ») := pqâ»;
--
-- NOTE: The positive form of tensor splitting is not yet supported.
--
-- This comes in handy when defining 'swapâ‚š':
--
--             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--            -â”‚   -â”Œâ”€â”€â”€â”+    â”‚+
--           â”€â”€â”¼â”€â”â”Œâ”€â”¤  pâ”œâ”€â”€â”â”Œâ”€â”¼â”€â”€
--   swap :    â”‚ â”‚â”‚ â””â”€â”€â”€â”˜  â”‚â”‚ â”‚
--            -â”‚ â””â”‚â”â”Œâ”€â”€â”€â”+ â””â”‚â”â”‚+
--           â”€â”€â”¼â”€â”€â”˜â””â”¤  qâ”œâ”€â”€â”€â”˜â””â”¼â”€â”€
--             â”‚   -â””â”€â”€â”€â”˜     â”‚
--             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

def swap (P Q : Poly) : (tensor-âŠ— P Q) â‡’ (tensor-âŠ— Q P) :=
  Î» (pâº , qâº) â‡œ (pâ» , qâ») â‡’
    return (qâº , pâº) â‡œ (qâ» , pâ»)

def swap' (P Q : Poly) : (tensor-âŠ— P Q) â‡’ (tensor-âŠ— Q P) :=
  Î» (pâº, qâº) â†’ ((qâº, pâº) , Î» (pâ», qâ») â†’ (qâ» , pâ») )

def swapâ‰¡swap' : Î (P Q : Poly), swap = swap' := Î» P Q â†’ refl

-- | Î»â» or Negative-lamda
--
-- Negative-lambda allows you to bind the fiber-sink of a Poly.  This
-- is useful to build the input side of a morphism.
--
--         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--        -â”‚  -â”Œâ”€â”€â”€â”+   â”‚+
--   f : â”€â”€â”¼â”€â”€*â”¤â„• â„•â”œâ”€â”€â”¬â”€â”¼â”€â”€
--        â„•â”‚  â”‚â””â”€â”€â”€â”˜  â”‚ â”‚â„•
--         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
--         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--      Note at * we apply 'add : â„• â†’ â„• â†’ â„•'
--

def f : (â„• Ã— y^â„•) â‡’ (â„• Ã— y^â„•) :=
  Î» nâº â‡œ nâ» â‡’
    return nâº â‡œ Î»â» (m : â„•) â†’ nâ» â† add m nâº; done

--------------------------------------------------------------------------------
-- | Moore Machines
--
-- â–†  If ğ´, ğµ, and ğ‘† are sets, an (ğ´, ğµ)-Moore machine with
-- â”‚  states ğ‘† consists of two functions
-- â”‚    return : ğ‘† â†’ ğµ
-- â”‚    update : ğ‘† Ã— ğ´ â†’ ğ‘†
--
-- An AB-Moore Machine is simply morphism between monomials:
--
--   SyË¢ â‡’ Oyá´µ

def Moore : Type â†’ Type â†’ Type â†’ Type :=
  Î» S I O â†’ (S Ã— y^S) â‡’ (O Ã— y^I)

-- The inner Poly 'S Ã— S' represents the internal state of the machine
-- and the outer Poly 'O Ã— I' describes the input and output types.
--
-- At any point in time the Machine is in some state 's âˆˆ S' and we
-- can use the output function to produce an output 'o âˆˆ O'. We can
-- also feed it an input 'i âˆˆ I' to switch to a new state using the
-- transition function and the current state.
--
-- We can write a helper function for building a Moore Machine from
-- output and transition functions:

def moore (S I O : Type) : (S â†’ O) â†’ (S â†’ I â†’ S) â†’ Moore S I O :=
  Î» output transition â†’
    Î» sâº â‡œ sâ» â‡’
      return (output sâº) â‡œ Î»â» (i : I) â†’ sâ» â† transition sâº i; done

def moore' (S I O : Type) : (S â†’ O) â†’ (S â†’ I â†’ S) â†’ Moore S I O :=
  Î» output transition s â†’
    (output s , transition s)

def mooreâ‰¡moore' : Î (S I O : Type), Î (out : S â†’ O), Î (trans : S â†’ I â†’ S),
  (moore S I O out trans) = (moore' S I O out trans) :=
    Î» S I O output transition â†’ refl

-- And then we can build the Three State Moore Machine example from the Poly Book (ex3.2):

def Command := #{ .Green, .Orange }
def Output := #{ .B1, .B2 }

-- | RGB Ã— RGB â‡’ Output Ã— Command
def three-state-moore : Moore RGB Command Output :=
  let output : RGB â†’ Output := {
      .Red   = .B1
    , .Green = .B2
    , .Blue  = .B2
  } in
  let transition : RGB â†’ Command â†’ RGB := {
      .Red   = { .Green = .Red  , .Orange = .Green }
    , .Green = { .Green = .Blue , .Orange = .Red }
    , .Blue  = { .Green = .Blue , .Orange = .Red }
  } in
  moore RGB Command Output output transition

-- Earlier we were introduced to counter which is in fact a Moore
-- Machine:

def counterâ‚š-is-a-machine : Moore â„• Unit â„• := counter

-- It can be redefined using the  'moore' function:

def counterâ‚˜ : Moore â„• Unit â„• :=
  moore â„• Unit â„• (Î» a â†’ a) (Î» n _ â†’ succ n)

-- And we can prove the equivalence of these two definitions:
def counterâ‚šâ‰¡counterâ‚˜ : counter = counterâ‚˜ := refl

--------------------------------------------------------------------------------
-- | Deterministic Finite State Automata
--
-- From a Moore Machine we can build DFSAs:

def DFSA : Type â†’ Type â†’ Type :=
  Î» S A â†’ Moore S A Bool

-- S is the DFSA state type and A is the alphabet.
--
-- Here we build a 3 State DFSA with a two symbol alphabet:

def three-state-dfsa : DFSA #{ .A, .B, .C} #{ .aâ‚€, .aâ‚ } :=
  let check : #{ .A, .B, .C } â†’ Bool :=
    { .A = .false
    , .B = .true
    , .C = .false }
  in
  let step : #{ .A, .B, .C } â†’ #{ .aâ‚€, .aâ‚ } â†’ #{ .A, .B, .C } :=
    { .A = { .aâ‚€ = .B, .aâ‚ = .C }
    , .B = { .aâ‚€ = .C, .aâ‚ = .B }
    , .C = { .aâ‚€ = .A, .aâ‚ = .A }
    }
  in
  Î» sâº â‡œ sâ» â‡’ return (check sâº) â‡œ (sâ» âˆ˜ (step sâº))

-- | Memoryless Dynamical System
--
-- We can also define the MDS from the Poly Book, defined as:
--
--   Byá´® â‡’ Byá´¬
--

def mds (A B : Type) : (A â†’ B) â†’ Moore B A B :=
  Î» f â†’
    Î» bâº â‡œ bâ» â‡’
      return bâº â‡œ Î»â» (a : A) â†’ bâ» â† f a; done

-- With 'mds' we can build the delay line and summation examples:

--            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--           -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
-- delayâ‚˜ : â”€â”€â”¼â”€â”€â”€â”¤â„• â„•â”œâ”€â”€â”€â”¼â”€â”€
--           â„•â”‚   â””â”€â”€â”€â”˜   â”‚â„•
--            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

def delayâ‚˜ : Moore â„• â„• â„• :=
  mds â„• â„• (Î» x â†’ x)

--          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--         -â”‚  -â”Œâ”€â”€â”€â”+  â”‚+
-- sumâ‚˜ : â”€â”€â”¼â”€*â”€â”¤â„• â„•â”œâ”€â”€â”€â”¼â”€â”€
--       â„•Ã—â„•â”‚   â””â”€â”€â”€â”˜   â”‚â„•
--          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--       Note at * we apply the addition operation

--def sumâ‚˜ : (â„• Ã— â„•) â‡’ (â„• Ã— (â„• Ã— â„•)) :=
def sumâ‚˜ : Moore â„• (â„• Ã— â„•) â„• :=
  mds (â„• Ã— â„•) â„• (Î» (x , y) â†’ add x y)

--------------------------------------------------------------------------------
-- | Deterministic Finite State Automata
--
--  â–† A deterministic state automaton consists of
--  â”‚ 1. a set ğ‘†, elements of which are called states;
--  â”‚ 2. a set ğ´, elements of which are called input symbols;
--  â”‚ 3. a function ğ‘¢ : ğ‘† Ã— ğ´ â†’ ğ‘†, called the update function;
--  â”‚ 4. an element ğ‘ 0 âˆˆ ğ‘†, called the initial state; and
--  â”‚ 5. a subset ğ¹ âŠ† ğ‘†, called the accept states.


-- DFSAs can be expressed with as a Moore Machine:

def DFSA : Type â†’ Type â†’ Type :=
  Î» S A â†’ Moore S A Bool


-- | Build a DFSA from its requisite components.
def dfsa : Î (S A : Type), ((S Ã— A) â†’ S) â†’ (S â†’ Bool) â†’ S â†’ DFSA S A :=
  Î» S A update check s â†’ moore S A Bool check (Î» s a â†’ update (s , a))

-- S is the DFSA state type and A is the alphabet.
--
-- Here we build a 3 State DFSA with a two symbol alphabet:

def three-state-dfsa : DFSA #{ .A, .B, .C} #{ .aâ‚€, .aâ‚ } :=
  let check : #{ .A, .B, .C } â†’ Bool :=
    { .A = .false
    , .B = .true
    , .C = .false }
  in
  let step : #{ .A, .B, .C } â†’ #{ .aâ‚€, .aâ‚ } â†’ #{ .A, .B, .C } :=
    { .A = { .aâ‚€ = .B, .aâ‚ = .C }
    , .B = { .aâ‚€ = .C, .aâ‚ = .B }
    , .C = { .aâ‚€ = .A, .aâ‚ = .A }
    }
  in
  Î» sâº â‡œ sâ» â‡’ return (check sâº) â‡œ (sâ» âˆ˜ (step sâº))

--------------------------------------------------------------------------------
-- | Dependent Dynamical Systems
--
-- â–† A dependent dynamical system (or a dependent Moore machine, or
-- | simply a dynamical system) is a lens
-- â”‚
-- â”‚   ğœ‘ : SyË¢ â‡’ P
-- â”‚
-- â”‚ for some ğ‘† âˆˆ Set and ğ‘ âˆˆ Poly. The set ğ‘† is called the set of
-- â”‚ statesâ€”with ğ‘†yË¢ called the state systemâ€”and the polynomial ğ‘ is called
-- â”‚ the interface. Positions of the interface are called outputs, and
-- â”‚ directions of the interface are called inputs
-- â”‚
-- â”‚ The lensâ€™s on-positions function ğœ‘â‚ : ğ‘† â†’ ğ‘(1) is called the return
-- â”‚ function, and for each ğ‘  âˆˆ ğ‘†, the lensâ€™s on-directions function ğœ‘â™¯ ğ‘  :
-- â”‚ ğ‘[ğœ‘â‚(ğ‘ )] â†’ ğ‘† is called the update function at ğ‘ .

def Command := #{ .Green, .Orange }
def Three : Type := #{ .One, .Two, .Three }

-- | ğœ‘ : ğ‘†yË¢ â†’ yáµƒ + 1.
-- def ex-321 : (Three Ã— Three) â‡’ tensor-+ (Unit Ã— Command) (Unit Ã— Unit) :=
--   let check : Three â†’ Either Unit Unit := { .One = Left Unit Unit .unit , .Three = Right Unit Unit .unit, .Two = Left Unit Unit .unit } in
--   let updateâ‚ : Command â†’ Three := { .Green = .One , .Orange = .Two } in
--   let updateâ‚‚ : Command â†’ Three := { .Green = .One , .Orange = .Three } in
--   let updateâ‚ƒ : Void â†’ Three := {} in
--   Î» stateâº â†’ (check stateâº , Î» x â†’ ?)

-- { .true = Î» v â†’ #{ .Green, .Orange }
-- , .false = Î» v â†’ #{ .unit }
-- } (fst ({ .One = (.true , .unit), .Three = (.false , .unit), .Two = (.true , .unit) } stateâº))
--   (snd ({ .One = (.true , .unit), .Three = (.false , .unit), .Two = (.true , .unit) } stateâº))


--------------------------------------------------------------------------------
-- | Interpretation of Poly Morphisms

-- We can use 'hom-base' and 'hom-fiber' to extract the base and fiber
-- respectively.

def identity : Î (A : Type), A â†’ A :=
  Î» A â†’
    hom-base (A Ã— y^A) (A Ã— y^A) (id (A Ã— y^A))

--def swap : Î (A B : Type), (A Ã— B) â†’ (B Ã— A) :=
--  Î» A B â†’
--    hom-base ((A Ã— B) Ã— (#{} Ã— y^#{})) ((B Ã— A) Ã— (#{} Ã— y^#{}))
--      (swapâ‚š (A Ã— y^#{}) (B Ã— y^#{}))

def delay : â„• â†’ â„• :=
  hom-base (â„• Ã— y^â„•) (â„• Ã— y^â„•) delayâ‚˜

def sum : (â„• Ã— â„•) â†’ â„• :=
  Î» nÃ—n â†’ hom-fiber (â„• Ã— y^â„•) (â„• Ã— y^(â„• Ã— â„•)) sumâ‚˜ 0 nÃ—n

--------------------------------------------------------------------------------
-- | Wiring Diagrams
--
-- The Poly book describes Wiring Diagrams as:
--
-- â–† Formally, and more precisely, we can think of each box in a wiring
-- â”‚ diagram as an interface given by some monomial. Then the entire
-- â”‚ wiring diagramâ€”specifying how these boxes nest within a larger
-- â”‚ boxâ€”is just an interaction pattern between the interfaces, with
-- â”‚ the larger box playing the role of the wrapper interface.
--  
--
--                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--	         -â”‚ -â”Œâ”€â”€â”€â”+ -â”Œâ”€â”€â”€â”+ â”‚+
-- two-chainâ‚š : â”€â”€â”¼â”€â”€â”¤ P â”œâ”€â”€â”€â”¤ Q â”œâ”€â”€â”¼â”€â”€
--               Aâ”‚ Aâ””â”€â”€â”€â”˜B Bâ””â”€â”€â”€â”˜C â”‚C
--                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

def two-chainâ‚š (A B C : Type) : (tensor-âŠ— (B Ã— y^A) (C Ã— y^B)) â‡’ (C Ã— y^A) :=
  Î» (pâº , qâº) â‡œ (pâ» , qâ») â‡’
     qâ» â† pâº;
     return qâº â‡œ pâ»

def plug : Î (A B C : Type),
  (A â†’ B) â†’ (B â†’ C) â†’ (tensor-âŠ— (B Ã— y^B) (C Ã— y^C)) â‡’ (tensor-âŠ— (B Ã— y^A) (C Ã— y^B)) :=
    Î» A B C f g â†’
      let fâ‚š : (B Ã— y^B) â‡’ (B Ã— y^A) := mds A B f in
      let gâ‚š : (C Ã— y^C) â‡’ (C Ã— y^B) := mds B C g in
      mux-âŠ— (B Ã— y^B) (B Ã— y^A) (C Ã— y^C) (C Ã— y^B) fâ‚š gâ‚š

def two-chain :
  Î (A B C : Type),
  (A â†’ B) â†’
  (B â†’ C) â†’
   (tensor-âŠ— (B Ã— y^B) (C Ã— y^C)) â‡’ (C Ã— y^A) :=
    Î» A B C f g â†’
      compose
      (tensor-âŠ— (B Ã— y^B) (C Ã— y^C))
      (tensor-âŠ— (B Ã— y^A) (C Ã— y^B))
      (C Ã— y^A)
      (two-chainâ‚š A B C)
      (plug A B C f g)

-- def compose :
--   Î (A B C : Type),
--   (A â†’ B) â†’
--   (B â†’ C) â†’
--   A â†’
--   (B Ã— C) :=
--   Î» A B C f g a â†’
--     let two-chain' := two-chain A B C f g
--     in hom-fiber ((B Ã— C) Ã— (B Ã— C)) (C Ã— A) two-chain' (? , ?) a

-- Here we use _â†_ to connect the 'fst' projection of the base of P to
-- the fiber-sink of Q.


--              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”             â”‚ 
--              â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”â”‚  â”Œâ”€â”€â”€â”€â”€â”    â”‚ 
--              â”‚  â””â”¤A    â”‚â”‚  â”‚     â”‚    â”‚ 
-- fib-wire : â”€â”€â”¤   â”‚  P Aâ”œâ”´â”€â”€â”¤A Q Aâ”œâ”¬â”€â”€â”€â”¼â”€â”€
--            ()â”‚  â”Œâ”¤A    â”‚   â”‚     â”‚â”‚   â”‚A
--              â”‚  â”‚â””â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”˜â”‚   â”‚ 
--              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ 
--              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

def fib-wire : Î (A : Type), (tensor-âŠ— (A Ã— y^(A Ã— A)) (A Ã— y^A)) â‡’ (A Ã— y^Unit) :=
  Î» A â†’
    Î» (pâº, qâº) â‡œ (pâ», qâ») â‡’
      return qâº â‡œ Î»â» _ â†’
        pâ» â† (pâº, qâº);
        qâ» â† pâº;
	done

def fib-wire' : Î (A : Type), (tensor-âŠ— (A Ã— y^(A Ã— A)) (A Ã— y^A)) â‡’ (A Ã— y^Unit) :=
  Î» A (pâº, qâº) â†’ (qâº , Î» _ â†’ ((pâº , qâº) , pâº))

def fib-wireâ‰¡fib-wire' : Î (A : Type), (fib-wire A) = (fib-wire' A) :=
  Î» A â†’ refl

-- With our wiring diagram defined, the next move is to tensor
-- together Moore machines to match the inner interface of the
-- diagram.
--
-- Fibonacci consists of an adder and a delay line, which we defined
-- previously, tensored with the parallel product:

def delayâŠ—sumâ‚˜ : (tensor-âŠ— (â„• Ã— y^â„•) (â„• Ã— y^â„•)) â‡’ (tensor-âŠ— (â„• Ã— y^(â„• Ã— â„•)) (â„• Ã— y^â„•)) :=
  mux-âŠ— (â„• Ã— y^â„•) (â„• Ã— y^(â„• Ã— â„•)) (â„• Ã— y^â„•) (â„• Ã— y^â„•) sumâ‚˜ delayâ‚˜ 

-- Notice that the outer interface of 'delayâŠ—sumâ‚˜' is the same shape as
-- the inner interface of 'fib-wire':
--
--  delayâŠ—sumâ‚˜ : (tensor-âŠ— (â„• Ã— â„•) (â„• Ã— â„•)) â‡’ (tensor-âŠ— (â„• Ã— (â„• Ã— â„•)) (â„• Ã— â„•))
--  fib-wire   :                 Î (A : Type), (tensor-âŠ— (A Ã— (A Ã— A)) (A Ã— A)) â‡’ (A Ã— Unit)
--   
-- This means we can use 'composeâ‚š' connect them together and produce
-- a poly morphism with the inner interface of 'delayâŠ—sumâ‚˜' and the
-- outer interface of 'fib-wire':

def fibâ‚˜ : Moore (â„• Ã— â„•) Unit â„• :=
  compose
    (tensor-âŠ— (â„• Ã— y^â„•) (â„• Ã— y^â„•))
    ((tensor-âŠ— (â„• Ã— y^(â„• Ã— â„•)) (â„• Ã— y^â„•)))
    ((â„• Ã— y^Unit))
    (fib-wire â„•)
    delayâŠ—sumâ‚˜

-- #normalize (step-moore (â„• Ã— â„•) Unit â„• .unit (3, 2) fibâ‚˜)

def input : List Unit := Cons Unit .unit (Cons Unit .unit ((Cons Unit .unit (Nil Unit))))
-- #normalize (process-moore (â„• Ã— â„•) Unit â„• (1, 1) input fibâ‚˜)

-- From here you can start to see the power Poly. We can build
-- granular Moore Machines which perform narrow behaviors, tensor them
-- together, and then compose them with wiring diagrams that describe
-- larger subroutines.
--
-- Those compositions themselves are themselves Moore Machines which
-- can be tensored with more Moore machines and then composed with a
-- wiring diagram to describe even larger subroutines.

--------------------------------------------------------------------------------
-- | Moore Machines as Lenses
-- TODO

--------------------------------------------------------------------------------
-- | Polynomial Composition: _â—_ 
-- TODO
