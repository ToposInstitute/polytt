def id : (A : Type) → A → A :=
  λ A x → x

def id_ : (A : Type) → A → A :=
  λ A x → x

def const : (A : Type) → (B : Type) → A → B → A :=
  λ _ _ x _ → x

def four : ℕ := 4

def double : ℕ → ℕ :=
  λ n → elim (λ _ → ℕ) 0 (λ _ → λ n → succ (succ n)) n

def add : ℕ → ℕ → ℕ :=
  λ m n → elim (λ _ → ℕ) n (λ _ n → succ n) m

def sigma : (A : Type) → (A → Type) → Type :=
  λ A → λ B → (x : A) × B x

def dup : (A : Type) → A → (A × A) :=
  λ _ a → (a , a)

def pair : ℕ → ℕ → (_ : ℕ) × ℕ :=
  λ n m → (n , m : ℕ)

def projl : (ℕ × ℕ) → ℕ :=
  λ x → fst x

def Bool := #{ .true, .false }

def Unit := (t : #{}) -> ({} : #{} -> Type) t

def unit : Unit := {}

def ARecord := { .true : ℕ, .false : Bool }

def record_lit : ARecord := { .true = 0, .false = .true }

def Anything := (T : Type) * T

def let-example :=
  let n = 5 : ℕ
  in n

#normalize let-example

def nyan : Poly :=
  (ℕ × ℕ)

def tensor : Poly → Poly → Poly :=
  λ P Q → (pq : base P × base Q) × (fib P (fst pq) × fib Q (snd pq))

#normalize base (tensor nyan nyan)
#normalize fib (tensor nyan nyan) (1 , 2)


def id : (P : Poly) → P ⇒ P :=
  λ P → λ a⁺ a⁻ ⇝
    a⁺ ⇜ a⁻

#print (λ P → P) : Poly → Poly

#print (λ P → λ a⁺ a⁻ ⇝ a⁺ ⇜ a⁻) : (P : Poly) → P ⇒ P

def nyan-hom : ℕ → nyan ⇒ nyan :=
  λ n → λ a⁺ a⁻ ⇝
    (a⁺ , a⁻) ⤚ (id nyan) → (b⁺ , b⁻);
    n ⇜ (b⁻ ∘ succ ∘ succ)

#normalize nyan-hom 42 1

def nyan-hom2 : nyan ⇒ nyan :=
  λ a⁺ a⁻ ⇝
    (a⁺ , a⁻) ⤚ (nyan-hom 12) → (b⁺ , b⁻);
    b⁺ ⇜ b⁻

#normalize nyan-hom2 1

def compose : (P : Poly) → (Q : Poly) → (R : Poly) → Q ⇒ R → P ⇒ Q → P ⇒ R :=
  λ P Q R f g → λ p⁺ p⁻ ⇝
    (p⁺ , p⁻) ⤚ g → (q⁺ , q⁻);
    (q⁺ , q⁻) ⤚ f → (r⁺ , r⁻);
    r⁺ ⇜ r⁻


-- 🐈🌈
#normalize (compose nyan nyan nyan nyan-hom2 nyan-hom2) 1

def counter : (ℕ × ℕ) ⇒ (ℕ × #{ .single }) :=
  λ n⁺ n⁻ ⇝
    n⁺ ⇜ (n⁻ ∘ (const ℕ #{ .single } (succ n⁺)))

#normalize counter

def Moore : Type → Type → Type → Type :=
  λ S I O → (S × S) ⇒ (O × I)

def mds : (A : Type) → (B : Type) → (A → B) → Moore B A B :=
  λ A B f → λ b⁺ b⁻ ⇝
    b⁺ ⇜ (b⁻ ∘ f)

def Gate : Type → Type → Type :=
  λ I O → Moore O I O

def test-pair : nyan ⇒ (tensor nyan nyan) :=
  λ n⁺ n⁻ ⇝
    (n⁺ , n⁻) ⤚ (nyan-hom 12) → (b⁺ , b⁻);
    ((n⁺ , b⁺)) ⇜ [! , λ _ → b⁻ ∘ succ]

#normalize (test-pair 1)

def swap : (P : Poly) → (Q : Poly) → tensor P Q ⇒ tensor Q P :=
  λ P Q → λ pq⁺ pq⁻ ⇝
    pq⁻ → (p⁻ , q⁻);
    ((snd pq⁺ , fst pq⁺)) ⇜ [q⁻ , λ _ → p⁻]

-- λ (p⁺, q⁺) (p⁻, q⁻) ⇝ (q⁺ , p⁺) , (q⁻ , p⁻)

#normalize swap nyan nyan (1, 2)

def internal-hom : Poly → Poly → Poly :=
  λ P Q → (f : P ⇒ Q) × ((p : base P) × fib Q (fst (f p)))

    -- ? → (q⁻ ∘ (snd ((snd pf⁺) (fst pf⁺))));
    -- (fst pf⁺ , p⁻) ⤚ (snd pf⁺) → (q₁⁺ , q₁⁻);
    -- (fst pf⁺) → pb⁻;
    -- q₁⁺ ⇜ q₁⁻

def eval : (P : Poly) → (Q : Poly) → tensor P (internal-hom P Q) ⇒ Q :=
  λ P Q → λ pf⁺ pf⁻ ⇝
    let p⁺ = fst pf⁺;
    let f⁺ = snd pf⁺;
    let qf⁺ = f⁺ p⁺;
    let q⁺ = fst qf⁺;
    pf⁻ → (p⁻ , f⁻);
    f⁻ → (pb⁻ , q⁻);
    (fst pf⁺) → pb⁻;
    let⁻ qf⁻ = λ⁻ (v : fib Q q⁺) →
      -- ignore this id_ ?, parsing bug
      (id_ (fib Q q⁺) v) → q⁻;
      ((snd qf⁺) v) → p⁻;
      end;
    (fst qf⁺) ⇜ qf⁻
    -- the following crashes due to bug :(
--    (fst qf⁺) ⇜ λ⁻ (v : fib Q q⁺) →
--      -- ignore this id_ ?, parsing bug
--      (id_ (fib Q q⁺) v) → q⁻;
--      ((snd qf⁺) v) → p⁻;
--      end

#normalize (eval nyan nyan) (3 , nyan-hom 12)

def compose : Poly → Poly → Poly :=
  λ P Q → (pf : (p : base P) × (fib P p → base Q)) × (i : fib P (fst pf)) × fib Q ((snd pf) i)

def tensor-to-compose : (P : Poly) → (Q : Poly) → tensor P Q ⇒ compose P Q :=
  λ P Q → λ pq⁺ pq⁻ ⇝
    (fst pq⁺ , λ _ → snd pq⁺) ⇜ pq⁻


