def id : Œ† (A : Type), A ‚Üí A :=
  Œª A x ‚Üí x

def id_ : Œ† (A : Type), A ‚Üí A :=
  Œª A x ‚Üí x

def const : Œ† (A B : Type), A ‚Üí B ‚Üí A :=
  Œª _ _ x _ ‚Üí x

def four : ‚Ñï := 4

def double : ‚Ñï ‚Üí ‚Ñï :=
  Œª n ‚Üí elim (Œª _ ‚Üí ‚Ñï) 0 (Œª _ ‚Üí Œª n ‚Üí succ (succ n)) n

def add : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï :=
  Œª m n ‚Üí elim (Œª _ ‚Üí ‚Ñï) n (Œª _ n ‚Üí succ n) m

def sigma : Œ† (A : Type), (A ‚Üí Type) ‚Üí Type :=
  Œª A B ‚Üí Œ£ (x : A), B x

def dup : Œ† (A : Type), A ‚Üí (A √ó A) :=
  Œª _ a ‚Üí (a , a)

def pair : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï √ó ‚Ñï :=
  Œª n m ‚Üí (n , m : ‚Ñï)

def projl : Œ† (T : Type), (‚Ñï √ó T) ‚Üí T :=
  Œª T (_ , x) ‚Üí x

def Bool := #{ .true, .false }

def Unit := Œ† (t : #{}), ({} : #{} -> Type) t

def unit : Unit := {}

def ARecord := { .true : ‚Ñï, .false : Bool }

def record_lit : ARecord := { .true = 0, .false = .true }

def Anything := Œ£ (T : Type), T

def let-example :=
  let n := 5 : ‚Ñï
  in n

#normalize let-example

def nyan : Poly :=
  (‚Ñï √ó ‚Ñï)

def tensor : Poly ‚Üí Poly ‚Üí Poly :=
  Œª P Q ‚Üí Œ£ ((p , q) : base P √ó base Q), fib P p √ó fib Q q

#print tensor
#normalize base (tensor nyan nyan)
#normalize fib (tensor nyan nyan) (1 , 2)


def id : Œ† (P : Poly), P ‚áí P :=
  Œª P ‚Üí Œª a‚Å∫ a‚Åª ‚áù
    return a‚Å∫ ‚áú a‚Åª

#print (Œª P ‚Üí P) : Poly ‚Üí Poly

#print (Œª P ‚Üí Œª a‚Å∫ a‚Åª ‚áù return a‚Å∫ ‚áú a‚Åª) : Œ† (P : Poly), P ‚áí P

def nyan-hom : ‚Ñï ‚Üí nyan ‚áí nyan :=
  Œª n ‚Üí Œª a‚Å∫ a‚Åª ‚áù
    let (b‚Å∫ ‚áú b‚Åª) := (id nyan) (a‚Å∫ ‚áú a‚Åª);
    return n ‚áú (b‚Åª ‚àò succ ‚àò succ)

#normalize nyan-hom 42 1

def nyan-hom2 : nyan ‚áí nyan :=
  Œª a‚Å∫ a‚Åª ‚áù
    let (b‚Å∫ ‚áú b‚Åª) := (nyan-hom 12) (a‚Å∫ ‚áú a‚Åª);
    return b‚Å∫ ‚áú b‚Åª

#normalize nyan-hom2 1

def compose : Œ† (P Q R : Poly), Q ‚áí R ‚Üí P ‚áí Q ‚Üí P ‚áí R :=
  Œª P Q R f g ‚Üí Œª p‚Å∫ p‚Åª ‚áù
    let (q‚Å∫ ‚áú q‚Åª) := g (p‚Å∫ ‚áú p‚Åª);
    let (r‚Å∫ ‚áú r‚Åª) := f (q‚Å∫ ‚áú q‚Åª);
    return r‚Å∫ ‚áú r‚Åª


-- üêàüåà
#normalize compose nyan nyan nyan nyan-hom2 nyan-hom2 1

def counter : (‚Ñï √ó ‚Ñï) ‚áí (‚Ñï √ó #{ .single }) :=
  Œª n‚Å∫ n‚Åª ‚áù
    return n‚Å∫ ‚áú Œª‚Åª (x : #{ .single }) ‚Üí n‚Åª ‚Üê succ n‚Å∫; done

#normalize (const ‚Ñï) ‚Ñï

#normalize counter

def Moore : Type ‚Üí Type ‚Üí Type ‚Üí Type :=
  Œª S I O ‚Üí (S √ó S) ‚áí (O √ó I)

def mds : Œ† (A B : Type), (A ‚Üí B) ‚Üí Moore B A B :=
  Œª A B f ‚Üí Œª b‚Å∫ b‚Åª ‚áù
    return b‚Å∫ ‚áú b‚Åª ‚àò f

def Gate : Type ‚Üí Type ‚Üí Type :=
  Œª I O ‚Üí Moore O I O

def test-pair : nyan ‚áí tensor nyan nyan :=
  Œª n‚Å∫ n‚Åª ‚áù
    let (b‚Å∫ ‚áú b‚Åª) := (nyan-hom 12) (n‚Å∫ ‚áú n‚Åª);
    return (n‚Å∫ , b‚Å∫) ‚áú ( ! ‚Üê _ , b‚Åª ‚àò succ )

#normalize (test-pair 1)

def swap : Œ† (P Q : Poly), tensor P Q ‚áí tensor Q P :=
  Œª P Q ‚Üí Œª (p‚Å∫ , q‚Å∫) (p‚Åª , q‚Åª) ‚áù
    return (q‚Å∫ , p‚Å∫) ‚áú (q‚Åª , p‚Åª)

-- Œª (p‚Å∫, q‚Å∫) (p‚Åª, q‚Åª) ‚áù (q‚Å∫ , p‚Å∫) , (q‚Åª , p‚Åª)

#normalize swap nyan nyan (1, 2)

def internal-hom : Poly ‚Üí Poly ‚Üí Poly :=
  Œª P Q ‚Üí Œ£ (f : P ‚áí Q), (Œ£ (p : base P), fib Q (fst (f p)))

    -- ? ‚Üí (q‚Åª ‚àò (snd ((snd pf‚Å∫) (fst pf‚Å∫))));
    -- (fst pf‚Å∫ , p‚Åª) ‚§ö (snd pf‚Å∫) ‚Üí (q‚ÇÅ‚Å∫ , q‚ÇÅ‚Åª);
    -- (fst pf‚Å∫) ‚Üí pb‚Åª;
    -- q‚ÇÅ‚Å∫ ‚áú q‚ÇÅ‚Åª

--            |----------------------------------------------------------------------------------------|
--            |   -( fib P p‚Å∫ )-[ p : P ]-( p‚Å∫ : base P )-\                                            |
--            |                                            \-( pb‚Åª : base P )-[ f : P=>Q ]-( f‚Å∫ : _)   |
-- fib Q q‚Å∫ *-|-----------------------------( fib Q (fst (f‚Å∫ (borrow pb‚Åª))) )-[ f : P=>Q ]            -|- q‚Å∫ : base Q
--            |----------------------------------------------------------------------------------------|

-- Œ† Œ£ Œ† Œ£

-- Œª a‚Å∫ a‚Åª ‚áù
--   p‚Åª ‚Üê p‚Å∫;
--   return (base f) a‚Å∫ ‚áú Œª r ‚Üí
--     p‚Åª ‚Üê p‚Å∫;
--     a‚Åª ‚Üê (fib b a‚Å∫) r;
--     done

-- Ideal syntax:
--def eval (P Q : Poly) : tensor P (internal-hom P Q) ‚áí Q :=
--  -- These two lines are equivalent:
--  -- either we take one (tensored) box, and deconstruct its bases (p‚Å∫ , f‚Å∫) and fibers (p‚ÇÅ‚Åª , (p‚ÇÇ‚Åª , q‚Åª))
--  -- Œª (p‚Å∫ , f‚Å∫) ‚áú (p‚ÇÅ‚Åª , (p‚ÇÇ‚Åª , q‚Åª)) ‚áù
--  -- or we take two boxes (implicitly tensored), and deconstruct each base and fiber separately
--  Œª (p‚Å∫ ‚áú p‚ÇÅ‚Åª) (f‚Å∫ ‚áú (p‚ÇÇ‚Åª , q‚Åª)) ‚áù
--    let (q‚Å∫ , bwd) := f‚Å∫ p‚Å∫;
--    p‚ÇÇ‚Åª ‚Üê p‚Å∫;
--    return
--      q‚Å∫ ‚áú Œª‚Åª (q : fib Q q‚Å∫) ‚Üí
--        q‚Åª ‚Üê q;
--        p‚ÇÅ‚Åª ‚Üê bwd q;
--        done

-- Œ† Œ£
-- P => Q
-- mbase : base P -> base Q
-- mfib : (p : base P) -> fib Q (mbase p) -> fib P p
--
-- m : Œ† (p : base P), Œ£ (q : base Q), fib Q q -> fib P p
-- mbase = fst . m : base P -> base Q
-- snd : (xy : Œ£ (x : X), Y x) -> Y (fst xy)
-- mfib = snd . m : (p : base P) -> fib Q (fst (m p)) -> fib P p

#normalize (Œª P Q ‚Üí base (tensor P (internal-hom P Q))) : Poly ‚Üí Poly ‚Üí Type

def eval : Œ† (P Q : Poly), tensor P (internal-hom P Q) ‚áí Q :=
  Œª P Q ‚Üí Œª pf‚Å∫ pf‚Åª ‚áù
    let p‚Å∫ := fst pf‚Å∫;
    let f‚Å∫ := snd pf‚Å∫;
    -- pf‚Åª : ((fib P p‚Å∫) √ó (fib (internal-hom P Q) f‚Å∫))‚Åª
    let‚Åª (p‚Åª , f‚Åª) := pf‚Åª;
    -- borrow pf‚Åª = (borrow p‚Åª , borrow f‚Åª)
    let qf‚Å∫ := f‚Å∫ p‚Å∫;
    let q‚Å∫ := fst qf‚Å∫;
    let‚Åª q‚ÇÅ‚Åª := p‚Åª ‚àò (snd qf‚Å∫);
    -- f‚Åª : ((p : base P) √ó fib Q (fst (f‚Å∫ p)))‚Åª
    let‚Åª (pb‚Åª , q‚Åª) := f‚Åª;
    -- pb‚Åª : (base P)‚Åª
    -- q‚Åª : (fib Q (fst (f‚Å∫ (borrow pb‚Åª))))‚Åª
    pb‚Åª ‚Üê p‚Å∫;
    -- q‚Åª : (fib Q (fst (f‚Å∫ p‚Å∫)))‚Åª
    -- q‚Åª : (fib Q q‚Å∫)‚Åª
    return q‚Å∫ ‚áú Œª‚Åª (v : fib Q q‚Å∫) ‚Üí
      (q‚ÇÅ‚Åª , q‚Åª) ‚Üê (v , v);
      done

def compose : Poly ‚Üí Poly ‚Üí Poly :=
  Œª P Q ‚Üí Œ£ (pf : Œ£ (p : base P), fib P p ‚Üí base Q), Œ£ (i : fib P (fst pf)), fib Q ((snd pf) i)

def tensor-to-compose : Œ† (P Q : Poly), tensor P Q ‚áí compose P Q :=
  Œª P Q ‚Üí Œª pq‚Å∫ pq‚Åª ‚áù
    return (fst pq‚Å∫ , Œª _ ‚Üí snd pq‚Å∫) ‚áú pq‚Åª

#normalize tensor-to-compose

def Lens : Œ† (S T A B : Type), Type := Œª S T A B ‚Üí { .get : S ‚Üí A, .set : S ‚Üí B ‚Üí T }

def compose : Œ† (A B C : Type), (B ‚Üí C) ‚Üí (A ‚Üí B) ‚Üí A ‚Üí C :=
  Œª _ _ _ f g a ‚Üí f (g a)

#normalize Lens
