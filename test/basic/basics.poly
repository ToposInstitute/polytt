def id : Î  (A : Type), A â†’ A :=
  Î» A x â†’ x

def id_ : Î  (A : Type), A â†’ A :=
  Î» A x â†’ x

def const : Î  (A B : Type), A â†’ B â†’ A :=
  Î» _ _ x _ â†’ x

def four : â„• := 4

def double : â„• â†’ â„• :=
  Î» n â†’ elim (Î» _ â†’ â„•) 0 (Î» _ â†’ Î» n â†’ succ (succ n)) n

def add : â„• â†’ â„• â†’ â„• :=
  Î» m n â†’ elim (Î» _ â†’ â„•) n (Î» _ n â†’ succ n) m

def sigma : Î  (A : Type), (A â†’ Type) â†’ Type :=
  Î» A B â†’ Î£ (x : A), B x

def dup : Î  (A : Type), A â†’ (A Ã— A) :=
  Î» _ a â†’ (a , a)

def pair : â„• â†’ â„• â†’ â„• Ã— â„• :=
  Î» n m â†’ (n , m : â„•)

def projl : (â„• Ã— â„•) â†’ â„• :=
  Î» (_ , x) â†’ x

def Bool := #{ .true, .false }

def Unit := Î  (t : #{}), ({} : #{} -> Type) t

def unit : Unit := {}

def ARecord := { .true : â„•, .false : Bool }

def record_lit : ARecord := { .true = 0, .false = .true }

def Anything := Î£ (T : Type), T

def let-example :=
  let n := 5 : â„•
  in n

#normalize let-example

def nyan : Poly :=
  (â„• Ã— â„•)

def tensor : Poly â†’ Poly â†’ Poly :=
  Î» P Q â†’ Î£ ((p , q) : base P Ã— base Q), fib P p Ã— fib Q q

#print tensor
#normalize base (tensor nyan nyan)
#normalize fib (tensor nyan nyan) (1 , 2)


def id : Î  (P : Poly), P â‡’ P :=
  Î» P â†’ Î» aâº â‡œ aâ» â‡
    return aâº â‡œ aâ»

#print (Î» P â†’ P) : Poly â†’ Poly

#print (Î» P â†’ Î» aâº â‡œ aâ» â‡ return aâº â‡œ aâ») : Î  (P : Poly), P â‡’ P

def nyan-hom : â„• â†’ nyan â‡’ nyan :=
  Î» n â†’ Î» aâº â‡œ aâ» â‡
    let (bâº â‡œ bâ») := (id nyan) (aâº â‡œ aâ»);
    return n â‡œ (bâ» âˆ˜ succ âˆ˜ succ)

#normalize nyan-hom 42 1

def nyan-hom2 : nyan â‡’ nyan :=
  Î» aâº â‡œ aâ» â‡
    let (bâº â‡œ bâ») := (nyan-hom 12) (aâº â‡œ aâ»);
    return bâº â‡œ bâ»

#normalize nyan-hom2 1

def compose : Î  (P Q R : Poly), Q â‡’ R â†’ P â‡’ Q â†’ P â‡’ R :=
  Î» P Q R f g â†’ Î» pâº â‡œ pâ» â‡
    let (qâº â‡œ qâ») := g (pâº â‡œ pâ»);
    let (râº â‡œ râ») := f (qâº â‡œ qâ»);
    return râº â‡œ râ»


-- ğŸˆğŸŒˆ
#normalize compose nyan nyan nyan nyan-hom2 nyan-hom2 1

def counter : (â„• Ã— â„•) â‡’ (â„• Ã— #{ .single }) :=
  Î» nâº â‡œ nâ» â‡
    return nâº â‡œ Î»â» (x : #{ .single }) â†’ nâ» â† succ nâº; done

#normalize (const â„•) â„•

#normalize counter

def Moore : Type â†’ Type â†’ Type â†’ Type :=
  Î» S I O â†’ (S Ã— S) â‡’ (O Ã— I)

def mds : Î  (A B : Type), (A â†’ B) â†’ Moore B A B :=
  Î» A B f â†’ Î» bâº â‡œ bâ» â‡
    return bâº â‡œ bâ» âˆ˜ f

def Gate : Type â†’ Type â†’ Type :=
  Î» I O â†’ Moore O I O

def test-pair : nyan â‡’ tensor nyan nyan :=
  Î» nâº â‡œ nâ» â‡
    let (bâº â‡œ bâ») := (nyan-hom 12) (nâº â‡œ nâ»);
    return (nâº , bâº) â‡œ (! , bâ» âˆ˜ succ)

#normalize (test-pair 1)

def swap : Î  (P Q : Poly), tensor P Q â‡’ tensor Q P :=
  Î» P Q â†’ Î» (pâº , qâº) â‡œ (pâ» , qâ») â‡
    return (qâº , pâº) â‡œ (qâ» , pâ»)

-- Î» (pâº, qâº) (pâ», qâ») â‡ (qâº , pâº) , (qâ» , pâ»)

#normalize swap nyan nyan (1, 2)

def internal-hom : Poly â†’ Poly â†’ Poly :=
  Î» P Q â†’ Î£ (f : P â‡’ Q), (Î£ (p : base P), fib Q (fst (f p)))

    -- ? â†’ (qâ» âˆ˜ (snd ((snd pfâº) (fst pfâº))));
    -- (fst pfâº , pâ») â¤š (snd pfâº) â†’ (qâ‚âº , qâ‚â»);
    -- (fst pfâº) â†’ pbâ»;
    -- qâ‚âº â‡œ qâ‚â»

--            |----------------------------------------------------------------------------------------|
--            |   -( fib P pâº )-[ p : P ]-( pâº : base P )-\                                            |
--            |                                            \-( pbâ» : base P )-[ f : P=>Q ]-( fâº : _)   |
-- fib Q qâº *-|-----------------------------( fib Q (fst (fâº (borrow pbâ»))) )-[ f : P=>Q ]            -|- qâº : base Q
--            |----------------------------------------------------------------------------------------|

-- Î  Î£ Î  Î£

-- Î» aâº â‡œ aâ» â‡
--   pâ» â† pâº;
--   return (base f) aâº â‡œ Î» r â†’
--     pâ» â† pâº;
--     aâ» â† (fib b aâº) r;
--     done

-- Ideal syntax:
--def eval (P Q : Poly) : tensor P (internal-hom P Q) â‡’ Q :=
--  -- These two lines are equivalent:
--  -- either we take one (tensored) box, and deconstruct its bases (pâº , fâº) and fibers (pâ‚â» , (pâ‚‚â» , qâ»))
--  -- Î» (pâº , fâº) â‡œ (pâ‚â» , (pâ‚‚â» , qâ»)) â‡
--  -- or we take two boxes (implicitly tensored), and deconstruct each base and fiber separately
--  Î» (pâº â‡œ pâ‚â») (fâº â‡œ (pâ‚‚â» , qâ»)) â‡
--    let (qâº , bwd) := fâº pâº;
--    pâ‚‚â» â† pâº;
--    return
--      qâº â‡œ Î»â» (q : fib Q qâº) â†’
--        qâ» â† q;
--        pâ‚â» â† bwd q;
--        done

-- Î  Î£
-- P => Q
-- mbase : base P -> base Q
-- mfib : (p : base P) -> fib Q (mbase p) -> fib P p
--
-- m : Î  (p : base P), Î£ (q : base Q), fib Q q -> fib P p
-- mbase = fst . m : base P -> base Q
-- snd : (xy : Î£ (x : X), Y x) -> Y (fst xy)
-- mfib = snd . m : (p : base P) -> fib Q (fst (m p)) -> fib P p

#normalize (Î» P Q â†’ base (tensor P (internal-hom P Q))) : Poly â†’ Poly â†’ Type

def eval : Î  (P Q : Poly), tensor P (internal-hom P Q) â‡’ Q :=
  Î» P Q â†’ Î» (pâº , fâº) â‡œ (qfâ» , (pâ» , qâ»)) â‡
    let (qâº , qfâº) := fâº pâº;
    pâ» â† pâº;
    return qâº â‡œ Î»â» (v : fib Q qâº) â†’
      (qfâ» , qâ») â† (qfâº v , v);
      done

def compose : Poly â†’ Poly â†’ Poly :=
  Î» P Q â†’ Î£ ((p , f) : Î£ (p : base P), fib P p â†’ base Q), Î£ (i : fib P p), fib Q (f i)

def tensor-to-compose : Î  (P Q : Poly), tensor P Q â‡’ compose P Q :=
  Î» P Q â†’ Î» (pâº , qâº) â‡œ pqâ» â‡
    return (pâº , Î» _ â†’ qâº) â‡œ pqâ»

#normalize tensor-to-compose

def Lens : Î  (S T A B : Type), Type := Î» S T A B â†’ { .get : S â†’ A, .set : S â†’ B â†’ T }

def compose : Î  (A B C : Type), (B â†’ C) â†’ (A â†’ B) â†’ A â†’ C :=
  Î» _ _ _ f g a â†’ f (g a)

#normalize Lens
